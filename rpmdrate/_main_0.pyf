!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module equilibrate_abf__user__routines 
    interface equilibrate_abf_user_interface 
        subroutine potential(q,v,dvdq,natoms,nbeads,result) ! in :_main:_main.f90:system:equilibrate_abf:unknown_interface
            double precision dimension(3,natoms,nbeads),intent(inout) :: q
            double precision dimension(nbeads),depend(nbeads) :: v
            double precision dimension(3,natoms,nbeads),depend(natoms,nbeads) :: dvdq
            integer, optional,intent(in),check(shape(q, 1) == natoms),depend(q) :: natoms=shape(q, 1)
            integer, optional,intent(in),check(shape(q, 2) == nbeads),depend(q) :: nbeads=shape(q, 2)
            integer intent(out) :: result
        end subroutine potential
    end interface equilibrate_abf_user_interface
end python module equilibrate_abf__user__routines
python module verlet_step_abf__user__routines 
    interface verlet_step_abf_user_interface 
        subroutine potential(q,v,dvdq,natoms,nbeads,result) ! in :_main:_main.f90:system:verlet_step_abf:unknown_interface
            double precision dimension(3,natoms,nbeads),intent(inout) :: q
            double precision dimension(nbeads),intent(inout),depend(nbeads) :: v
            double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: dvdq
            integer, optional,intent(in),check(shape(q, 1) == natoms),depend(q) :: natoms=shape(q, 1)
            integer, optional,intent(in),check(shape(q, 2) == nbeads),depend(q) :: nbeads=shape(q, 2)
            integer intent(out) :: result
        end subroutine potential
    end interface verlet_step_abf_user_interface
end python module verlet_step_abf__user__routines
python module equilibrate__user__routines 
    interface equilibrate_user_interface 
        subroutine potential(q,v,dvdq,natoms,nbeads,result) ! in :_main:_main.f90:system:equilibrate:unknown_interface
            double precision dimension(3,natoms,nbeads),intent(inout) :: q
            double precision dimension(nbeads),depend(nbeads) :: v
            double precision dimension(3,natoms,nbeads),depend(natoms,nbeads) :: dvdq
            integer, optional,intent(in),check(shape(q, 1) == natoms),depend(q) :: natoms=shape(q, 1)
            integer, optional,intent(in),check(shape(q, 2) == nbeads),depend(q) :: nbeads=shape(q, 2)
            integer intent(out) :: result
        end subroutine potential
    end interface equilibrate_user_interface
end python module equilibrate__user__routines
python module recrossing_trajectory__user__routines 
    interface recrossing_trajectory_user_interface 
        subroutine potential(q,v,dvdq,natoms,nbeads,result) ! in :_main:_main.f90:system:recrossing_trajectory:unknown_interface
            double precision dimension(3,natoms,nbeads),intent(inout) :: q
            double precision dimension(nbeads),depend(nbeads) :: v
            double precision dimension(3,natoms,nbeads),depend(natoms,nbeads) :: dvdq
            integer, optional,intent(in),check(shape(q, 1) == natoms),depend(q) :: natoms=shape(q, 1)
            integer, optional,intent(in),check(shape(q, 2) == nbeads),depend(q) :: nbeads=shape(q, 2)
            integer intent(out) :: result
        end subroutine potential
    end interface recrossing_trajectory_user_interface
end python module recrossing_trajectory__user__routines
python module umbrella_trajectory__user__routines 
    interface umbrella_trajectory_user_interface 
        subroutine potential(q,v,dvdq,natoms,nbeads,result) ! in :_main:_main.f90:system:umbrella_trajectory:unknown_interface
            double precision dimension(3,natoms,nbeads),intent(inout) :: q
            double precision dimension(nbeads),depend(nbeads) :: v
            double precision dimension(3,natoms,nbeads),depend(natoms,nbeads) :: dvdq
            integer, optional,intent(in),check(shape(q, 1) == natoms),depend(q) :: natoms=shape(q, 1)
            integer, optional,intent(in),check(shape(q, 2) == nbeads),depend(q) :: nbeads=shape(q, 2)
            integer intent(out) :: result
        end subroutine potential
    end interface umbrella_trajectory_user_interface
end python module umbrella_trajectory__user__routines
python module verlet_step__user__routines 
    interface verlet_step_user_interface 
        subroutine potential(q,v,dvdq,natoms,nbeads,result) ! in :_main:_main.f90:system:verlet_step:unknown_interface
            double precision dimension(3,natoms,nbeads),intent(inout) :: q
            double precision dimension(nbeads),intent(inout),depend(nbeads) :: v
            double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: dvdq
            integer, optional,intent(in),check(shape(q, 1) == natoms),depend(q) :: natoms=shape(q, 1)
            integer, optional,intent(in),check(shape(q, 2) == nbeads),depend(q) :: nbeads=shape(q, 2)
            integer intent(out) :: result
        end subroutine potential
    end interface verlet_step_user_interface
end python module verlet_step__user__routines
python module _main ! in 
    interface  ! in :_main
        module system ! in :_main:_main.f90
            integer, parameter,optional :: max_atoms=100
            double precision :: dt
            double precision :: beta
            double precision dimension(100) :: mass
            integer :: mode
            double precision, optional :: pi=dacos(-1.0d0)
            double precision, allocatable,dimension(:,:) :: cc
            double precision, allocatable,dimension(:,:) :: icc
            integer, optional :: allcc=0
            integer :: thermostat
            double precision :: andersen_sampling_time
            integer, parameter,optional :: max_gle_ns=20
            integer :: gle_ns
            double precision dimension(21,21) :: gle_a
            double precision dimension(21,21) :: gle_c
            double precision, save,allocatable,dimension(:,:) :: gle_s
            double precision, save,allocatable,dimension(:,:) :: gle_t
            double precision, save,allocatable,dimension(:,:,:,:) :: gle_p
            double precision, save,allocatable,dimension(:,:,:,:) :: gle_np
            integer :: if_file_child
            integer, parameter,optional :: n_in=1
            integer, parameter,optional :: n_hid_0=16
            integer, parameter,optional :: n_hid_1=8
            double precision dimension(1,16) :: weights1
            double precision dimension(16,8) :: weights2
            double precision dimension(8,1) :: weights3
            double precision dimension(1,16) :: bias1
            double precision dimension(1,8) :: bias2
            double precision :: bias3
            double precision :: xmax
            double precision :: xmin
            double precision :: ymax
            double precision :: ymin
            subroutine initialize_mlabf ! in :_main:_main.f90:system
            end subroutine initialize_mlabf
            subroutine ml_abf_model(in,value3,length) ! in :_main:_main.f90:system
                double precision dimension(length,1) :: in
                double precision dimension(length,1),intent(out),depend(length) :: value3
                integer, optional,intent(in),check(shape(in, 0) == length),depend(in) :: length=shape(in, 0)
            end subroutine ml_abf_model
            subroutine ml_abf_field(xi,dadxi) ! in :_main:_main.f90:system
                double precision intent(in) :: xi
                double precision intent(out) :: dadxi
            end subroutine ml_abf_field
            subroutine add_abf_potential(xi,dxi,v,dvdq,natoms,nbeads) ! in :_main:_main.f90:system
                double precision intent(in) :: xi
                double precision dimension(3,natoms),intent(in) :: dxi
                double precision dimension(nbeads),intent(inout) :: v
                double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: dvdq
                integer, optional,intent(in),check(shape(dxi, 1) == natoms),depend(dxi) :: natoms=shape(dxi, 1)
                integer, optional,intent(in),check(shape(v, 0) == nbeads),depend(v) :: nbeads=shape(v, 0)
            end subroutine add_abf_potential
            subroutine equilibrate_abf(t,p,q,xi_list,natoms,nbeads,steps,potential,result) ! in :_main:_main.f90:system
                use transition_state, only: check_for_valid_position
                use equilibrate_abf__user__routines
                double precision intent(inout) :: t
                double precision dimension(3,natoms,nbeads),intent(inout) :: p
                double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: q
                double precision dimension(steps),intent(inout) :: xi_list
                integer, optional,intent(in),check(shape(p, 1) == natoms),depend(p) :: natoms=shape(p, 1)
                integer, optional,intent(in),check(shape(p, 2) == nbeads),depend(p) :: nbeads=shape(p, 2)
                integer, optional,intent(in),check(shape(xi_list, 0) == steps),depend(xi_list) :: steps=shape(xi_list, 0)
                external potential
                integer intent(out) :: result
            end subroutine equilibrate_abf
            subroutine verlet_step_abf(t,p,q,v,dvdq,xi,dxi,d2xi,natoms,nbeads,xi_current,potential,kforce,constrain,result,ensemble) ! in :_main:_main.f90:system
                use verlet_step_abf__user__routines
                double precision intent(inout) :: t
                double precision dimension(3,natoms,nbeads),intent(inout) :: p
                double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: q
                double precision dimension(nbeads),intent(inout),depend(nbeads) :: v
                double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: dvdq
                double precision intent(inout) :: xi
                double precision dimension(3,natoms),intent(inout),depend(natoms) :: dxi
                double precision dimension(3,natoms,3,natoms),intent(inout),depend(natoms) :: d2xi
                integer, optional,intent(in),check(shape(p, 1) == natoms),depend(p) :: natoms=shape(p, 1)
                integer, optional,intent(in),check(shape(p, 2) == nbeads),depend(p) :: nbeads=shape(p, 2)
                double precision intent(in) :: xi_current
                external potential
                double precision intent(in) :: kforce
                integer intent(in) :: constrain
                integer intent(out) :: result
                character*3 intent(in) :: ensemble
            end subroutine verlet_step_abf
            subroutine equilibrate(t,p,q,natoms,nbeads,steps,xi_current,potential,kforce,constrain,save_trajectory,result) ! in :_main:_main.f90:system
                use transition_state, only: check_for_valid_position
                use equilibrate__user__routines
                double precision intent(inout) :: t
                double precision dimension(3,natoms,nbeads),intent(inout) :: p
                double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: q
                integer, optional,intent(in),check(shape(p, 1) == natoms),depend(p) :: natoms=shape(p, 1)
                integer, optional,intent(in),check(shape(p, 2) == nbeads),depend(p) :: nbeads=shape(p, 2)
                integer intent(in) :: steps
                double precision intent(in) :: xi_current
                external potential
                double precision intent(in) :: kforce
                integer intent(in) :: constrain
                integer :: save_trajectory
                integer intent(out) :: result
            end subroutine equilibrate
            subroutine recrossing_trajectory(t,p,q,natoms,nbeads,steps,xi_current,potential,save_trajectory,kappa_num,kappa_denom,result,cor) ! in :_main:_main.f90:system
                use recrossing_trajectory__user__routines
                double precision intent(inout) :: t
                double precision dimension(3,natoms,nbeads),intent(inout) :: p
                double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: q
                integer, optional,intent(in),check(shape(p, 1) == natoms),depend(p) :: natoms=shape(p, 1)
                integer, optional,intent(in),check(shape(p, 2) == nbeads),depend(p) :: nbeads=shape(p, 2)
                integer, optional,intent(in),check(shape(kappa_num, 0) == steps),depend(kappa_num) :: steps=shape(kappa_num, 0)
                double precision intent(in) :: xi_current
                external potential
                integer :: save_trajectory
                double precision dimension(steps),intent(inout) :: kappa_num
                double precision intent(inout) :: kappa_denom
                integer intent(out) :: result
                integer intent(in) :: cor
            end subroutine recrossing_trajectory
            subroutine umbrella_trajectory(t,p,q,natoms,nbeads,steps,xi_current,potential,kforce,xi_range,save_trajectory,av,av2,actual_steps,result) ! in :_main:_main.f90:system
                use transition_state, only: check_for_valid_position,check_values
                use umbrella_trajectory__user__routines
                double precision intent(inout) :: t
                double precision dimension(3,natoms,nbeads),intent(inout) :: p
                double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: q
                integer, optional,intent(in),check(shape(p, 1) == natoms),depend(p) :: natoms=shape(p, 1)
                integer, optional,intent(in),check(shape(p, 2) == nbeads),depend(p) :: nbeads=shape(p, 2)
                integer intent(in) :: steps
                double precision intent(in) :: xi_current
                external potential
                double precision intent(in) :: kforce
                double precision intent(in) :: xi_range
                integer intent(in) :: save_trajectory
                double precision intent(out) :: av
                double precision intent(out) :: av2
                integer intent(out) :: actual_steps
                integer intent(out) :: result
            end subroutine umbrella_trajectory
            subroutine verlet_step(t,p,q,v,dvdq,xi,dxi,d2xi,natoms,nbeads,xi_current,potential,kforce,constrain,result,ensemble) ! in :_main:_main.f90:system
                use verlet_step__user__routines
                double precision intent(inout) :: t
                double precision dimension(3,natoms,nbeads),intent(inout) :: p
                double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: q
                double precision dimension(nbeads),intent(inout),depend(nbeads) :: v
                double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: dvdq
                double precision intent(inout) :: xi
                double precision dimension(3,natoms),intent(inout),depend(natoms) :: dxi
                double precision dimension(3,natoms,3,natoms),intent(inout),depend(natoms) :: d2xi
                integer, optional,intent(in),check(shape(p, 1) == natoms),depend(p) :: natoms=shape(p, 1)
                integer, optional,intent(in),check(shape(p, 2) == nbeads),depend(p) :: nbeads=shape(p, 2)
                double precision intent(in) :: xi_current
                external potential
                double precision intent(in) :: kforce
                integer intent(in) :: constrain
                integer intent(out) :: result
                character*3 intent(in) :: ensemble
            end subroutine verlet_step
            subroutine init_dft_cc(nbeads,dftcc,idftcc) ! in :_main:_main.f90:system
                integer, optional,intent(in),check(shape(dftcc, 0) == nbeads),depend(dftcc) :: nbeads=shape(dftcc, 0)
                double precision dimension(nbeads,nbeads),intent(in) :: dftcc
                double precision dimension(nbeads,nbeads),intent(in),depend(nbeads) :: idftcc
            end subroutine init_dft_cc
            subroutine free_ring_polymer_step(p,q,natoms,nbeads,ensemble) ! in :_main:_main.f90:system
                double precision dimension(3,natoms,nbeads),intent(inout) :: p
                double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: q
                integer, optional,intent(in),check(shape(p, 1) == natoms),depend(p) :: natoms=shape(p, 1)
                integer, optional,intent(in),check(shape(p, 2) == nbeads),depend(p) :: nbeads=shape(p, 2)
                character*3 intent(in) :: ensemble
            end subroutine free_ring_polymer_step
            subroutine constrain_to_dividing_surface(p,q,dxi,natoms,nbeads,xi_current,info) ! in :_main:_main.f90:system
                double precision dimension(3,natoms,nbeads),intent(inout) :: p
                double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: q
                double precision dimension(3,natoms),intent(inout),depend(natoms) :: dxi
                integer, optional,intent(in),check(shape(p, 1) == natoms),depend(p) :: natoms=shape(p, 1)
                integer, optional,intent(in),check(shape(p, 2) == nbeads),depend(p) :: nbeads=shape(p, 2)
                double precision intent(in) :: xi_current
                integer intent(out) :: info
            end subroutine constrain_to_dividing_surface
            subroutine constrain_momentum_to_dividing_surface(p,dxi,natoms,nbeads) ! in :_main:_main.f90:system
                double precision dimension(3,natoms,nbeads),intent(inout) :: p
                double precision dimension(3,natoms),intent(in),depend(natoms) :: dxi
                integer, optional,intent(in),check(shape(p, 1) == natoms),depend(p) :: natoms=shape(p, 1)
                integer, optional,intent(in),check(shape(p, 2) == nbeads),depend(p) :: nbeads=shape(p, 2)
            end subroutine constrain_momentum_to_dividing_surface
            subroutine add_umbrella_potential(xi,dxi,v,dvdq,natoms,nbeads,xi_current,kforce) ! in :_main:_main.f90:system
                double precision intent(in) :: xi
                double precision dimension(3,natoms),intent(in) :: dxi
                double precision dimension(nbeads),intent(inout) :: v
                double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: dvdq
                integer, optional,intent(in),check(shape(dxi, 1) == natoms),depend(dxi) :: natoms=shape(dxi, 1)
                integer, optional,intent(in),check(shape(v, 0) == nbeads),depend(v) :: nbeads=shape(v, 0)
                double precision intent(in) :: xi_current
                double precision intent(in) :: kforce
            end subroutine add_umbrella_potential
            subroutine add_bias_potential(dxi,d2xi,v,dvdq,natoms,nbeads) ! in :_main:_main.f90:system
                double precision dimension(3,natoms),intent(in) :: dxi
                double precision dimension(3,natoms,3,natoms),intent(in),depend(natoms) :: d2xi
                double precision dimension(nbeads),intent(inout) :: v
                double precision dimension(3,natoms,nbeads),intent(inout),depend(natoms,nbeads) :: dvdq
                integer, optional,intent(in),check(shape(dxi, 1) == natoms),depend(dxi) :: natoms=shape(dxi, 1)
                integer, optional,intent(in),check(shape(v, 0) == nbeads),depend(v) :: nbeads=shape(v, 0)
            end subroutine add_bias_potential
            subroutine get_reaction_coordinate(centroid,natoms,xi_current,xi,dxi,d2xi) ! in :_main:_main.f90:system
                use reactants, only: reactants_value=>value,reactants_gradient=>gradient,reactants_hessian=>hessian
                use transition_state, only: transition_state_value=>value,transition_state_gradient=>gradient,transition_state_hessian=>hessian
                double precision dimension(3,natoms),intent(in) :: centroid
                integer, optional,intent(in),check(shape(centroid, 1) == natoms),depend(centroid) :: natoms=shape(centroid, 1)
                double precision intent(in) :: xi_current
                double precision intent(out) :: xi
                double precision dimension(3,natoms),intent(out),depend(natoms) :: dxi
                double precision dimension(3,natoms,3,natoms),intent(out),depend(natoms) :: d2xi
            end subroutine get_reaction_coordinate
            subroutine get_recrossing_flux(dxi,natoms,fs) ! in :_main:_main.f90:system
                double precision dimension(3,natoms),intent(in) :: dxi
                integer, optional,intent(in),check(shape(dxi, 1) == natoms),depend(dxi) :: natoms=shape(dxi, 1)
                double precision intent(out) :: fs
            end subroutine get_recrossing_flux
            subroutine get_recrossing_velocity(p,dxi,natoms,nbeads,vs) ! in :_main:_main.f90:system
                double precision dimension(3,natoms,nbeads),intent(in) :: p
                double precision dimension(3,natoms),intent(in),depend(natoms) :: dxi
                integer, optional,intent(in),check(shape(p, 1) == natoms),depend(p) :: natoms=shape(p, 1)
                integer, optional,intent(in),check(shape(p, 2) == nbeads),depend(p) :: nbeads=shape(p, 2)
                double precision intent(out) :: vs
            end subroutine get_recrossing_velocity
            subroutine sample_momentum(p,mass,beta,natoms,nbeads) ! in :_main:_main.f90:system
                double precision dimension(3,natoms,nbeads),intent(out),depend(natoms,nbeads) :: p
                double precision dimension(natoms),intent(in) :: mass
                double precision intent(in) :: beta
                integer, optional,intent(in),check(shape(mass, 0) == natoms),depend(mass) :: natoms=shape(mass, 0)
                integer intent(in) :: nbeads
            end subroutine sample_momentum
            subroutine get_ring_polymer_energy(q,natoms,nbeads,ering) ! in :_main:_main.f90:system
                double precision dimension(3,natoms,nbeads),intent(in) :: q
                integer, optional,intent(in),check(shape(q, 1) == natoms),depend(q) :: natoms=shape(q, 1)
                integer, optional,intent(in),check(shape(q, 2) == nbeads),depend(q) :: nbeads=shape(q, 2)
                double precision intent(out) :: ering
            end subroutine get_ring_polymer_energy
            subroutine get_kinetic_energy(p,natoms,nbeads,ek) ! in :_main:_main.f90:system
                double precision dimension(3,natoms,nbeads),intent(in) :: p
                integer, optional,intent(in),check(shape(p, 1) == natoms),depend(p) :: natoms=shape(p, 1)
                integer, optional,intent(in),check(shape(p, 2) == nbeads),depend(p) :: nbeads=shape(p, 2)
                double precision intent(out) :: ek
            end subroutine get_kinetic_energy
            subroutine get_center_of_mass(q,natoms,nbeads,cm) ! in :_main:_main.f90:system
                double precision dimension(3,natoms,nbeads),intent(in) :: q
                integer, optional,intent(in),check(shape(q, 1) == natoms),depend(q) :: natoms=shape(q, 1)
                integer, optional,intent(in),check(shape(q, 2) == nbeads),depend(q) :: nbeads=shape(q, 2)
                double precision dimension(3),intent(out) :: cm
            end subroutine get_center_of_mass
            subroutine get_centroid(q,natoms,nbeads,centroid) ! in :_main:_main.f90:system
                double precision dimension(3,natoms,nbeads),intent(in) :: q
                integer, optional,intent(in),check(shape(q, 1) == natoms),depend(q) :: natoms=shape(q, 1)
                integer, optional,intent(in),check(shape(q, 2) == nbeads),depend(q) :: nbeads=shape(q, 2)
                double precision dimension(3,natoms),intent(out),depend(natoms) :: centroid
            end subroutine get_centroid
            subroutine get_radius_of_gyration(q,natoms,nbeads,r) ! in :_main:_main.f90:system
                double precision dimension(3,natoms,nbeads),intent(in) :: q
                integer, optional,intent(in),check(shape(q, 1) == natoms),depend(q) :: natoms=shape(q, 1)
                integer, optional,intent(in),check(shape(q, 2) == nbeads),depend(q) :: nbeads=shape(q, 2)
                double precision dimension(natoms),intent(out),depend(natoms) :: r
            end subroutine get_radius_of_gyration
            subroutine update_vmd_output(q,natoms,nbeads,beads_file_number,centroid_file_number,p,v) ! in :_main:_main.f90:system
                double precision dimension(3,natoms,nbeads),intent(in) :: q
                integer, optional,intent(in),check(shape(q, 1) == natoms),depend(q) :: natoms=shape(q, 1)
                integer, optional,intent(in),check(shape(q, 2) == nbeads),depend(q) :: nbeads=shape(q, 2)
                integer intent(in) :: beads_file_number
                integer intent(in) :: centroid_file_number
                real(kind=8), optional,dimension(3,natoms,nbeads),intent(in),depend(natoms,nbeads) :: p
                real(kind=8), optional,dimension(nbeads),intent(in),depend(nbeads) :: v
            end subroutine update_vmd_output
            subroutine gle_initialize(dt,natoms,nbeads,a,c,ns) ! in :_main:_main.f90:system
                double precision intent(in) :: dt
                integer intent(in) :: natoms
                integer intent(in) :: nbeads
                double precision dimension(1 + ns,1 + ns),intent(in) :: a
                double precision dimension(1 + ns,1 + ns),intent(in),depend(ns) :: c
                integer, optional,intent(in),check(shape(a, 0) == 1 + ns),depend(a) :: ns=-1 + shape(a, 0)
            end subroutine gle_initialize
            subroutine gle_thermostat(p,mass,beta,dxi,natoms,nbeads,ns,constrain,result) ! in :_main:_main.f90:system
                double precision dimension(3,natoms,nbeads),intent(inout) :: p
                double precision dimension(natoms),intent(in),depend(natoms) :: mass
                double precision intent(in) :: beta
                double precision dimension(3,natoms),intent(in),depend(natoms) :: dxi
                integer, optional,intent(in),check(shape(p, 1) == natoms),depend(p) :: natoms=shape(p, 1)
                integer, optional,intent(in),check(shape(p, 2) == nbeads),depend(p) :: nbeads=shape(p, 2)
                integer intent(in) :: ns
                integer intent(in) :: constrain
                integer intent(inout) :: result
            end subroutine gle_thermostat
            subroutine gle_cleanup ! in :_main:_main.f90:system
            end subroutine gle_cleanup
        end module system
    end interface 
end python module _main

! This file was auto-generated with f2py (version:1.23.5).
! See:
! https://web.archive.org/web/20140822061353/http://cens.ioc.ee/projects/f2py2e

/* File: _mainmodule.c
 * This file is auto-generated with f2py (version:2).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date: Fri Jun 30 13:51:05 2023
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern "C" {
#endif

/*********************** See f2py2e/cfuncs.py: includes ***********************/
#include <stdarg.h>
#include "Python.h"
#include "fortranobject.h"
#include <string.h>
#include <setjmp.h>
#include <math.h>

/**************** See f2py2e/rules.py: mod_rules['modulebody'] ****************/
static PyObject *_main_error;
static PyObject *_main_module;

/*********************** See f2py2e/cfuncs.py: typedefs ***********************/
typedef signed char signed_char;

/****************** See f2py2e/cfuncs.py: typedefs_generated ******************/
typedef void(*cb_potential_in__main__user__routines_typedef)(double *,double *,double *,int *,int *,int *);

/********************** See f2py2e/cfuncs.py: cppmacros **********************/
#define PRINTPYOBJERR(obj)\
    fprintf(stderr,"_main.error is related to ");\
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");

#define pyobj_from_double1(v) (PyFloat_FromDouble(v))
\
#define FAILNULL(p) do {                                            \
    if ((p) == NULL) {                                              \
        PyErr_SetString(PyExc_MemoryError, "NULL pointer found");   \
        goto capi_fail;                                             \
    }                                                               \
} while (0)

#define MEMCOPY(to,from,n)\
    do { FAILNULL(to); FAILNULL(from); (void)memcpy(to,from,n); } while (0)

#define GETSCALARFROMPYTUPLE(tuple,index,var,ctype,mess) {\
        if ((capi_tmp = PyTuple_GetItem((tuple),(index)))==NULL) goto capi_fail;\
        if (!(ctype ## _from_pyobj((var),capi_tmp,mess)))\
            goto capi_fail;\
    }

#define pyobj_from_int1(v) (PyInt_FromLong(v))
#ifdef DEBUGCFUNCS
#define CFUNCSMESS(mess) fprintf(stderr,"debug-capi:"mess);
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) \
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");
#else
#define CFUNCSMESS(mess)
#define CFUNCSMESSPY(mess,obj)
#endif

#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F
#else
#define F_FUNC(f,F) _##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F##_
#else
#define F_FUNC(f,F) _##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F
#else
#define F_FUNC(f,F) f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F##_
#else
#define F_FUNC(f,F) f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_)
#else
#define F_FUNC_US(f,F) F_FUNC(f,F)
#endif

#ifndef max
#define max(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a < b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b) ((a < b) ? (a) : (b))
#endif

#define rank(var) var ## _Rank
#define shape(var,dim) var ## _Dims[dim]
#define old_rank(var) (PyArray_NDIM((PyArrayObject *)(capi_ ## var ## _tmp)))
#define old_shape(var,dim) PyArray_DIM(((PyArrayObject *)(capi_ ## var ## _tmp)),dim)
#define fshape(var,dim) shape(var,rank(var)-dim-1)
#define len(var) shape(var,0)
#define flen(var) fshape(var,0)
#define old_size(var) PyArray_SIZE((PyArrayObject *)(capi_ ## var ## _tmp))
/* #define index(i) capi_i ## i */
#define slen(var) capi_ ## var ## _len
#define size(var, ...) f2py_size((PyArrayObject *)(capi_ ## var ## _tmp), ## __VA_ARGS__, -1)

#define CHECKSCALAR(check,tcheck,name,show,var)\
    if (!(check)) {\
        char errstring[256];\
        sprintf(errstring, "%s: "show, "("tcheck") failed for "name, var);\
        PyErr_SetString(_main_error,errstring);\
        /*goto capi_fail;*/\
    } else 
#define SWAP(a,b,t) {\
    t *c;\
    c = a;\
    a = b;\
    b = c;}

/* New SciPy */
#define TRYPYARRAYTEMPLATECHAR case NPY_STRING: *(char *)(PyArray_DATA(arr))=*v; break;
#define TRYPYARRAYTEMPLATELONG case NPY_LONG: *(long *)(PyArray_DATA(arr))=*v; break;
#define TRYPYARRAYTEMPLATEOBJECT case NPY_OBJECT: PyArray_SETITEM(arr,PyArray_DATA(arr),pyobj_from_ ## ctype ## 1(*v)); break;

#define TRYPYARRAYTEMPLATE(ctype,typecode) \
        PyArrayObject *arr = NULL;\
        if (!obj) return -2;\
        if (!PyArray_Check(obj)) return -1;\
        if (!(arr=(PyArrayObject *)obj)) {fprintf(stderr,"TRYPYARRAYTEMPLATE:");PRINTPYOBJERR(obj);return 0;}\
        if (PyArray_DESCR(arr)->type==typecode)  {*(ctype *)(PyArray_DATA(arr))=*v; return 1;}\
        switch (PyArray_TYPE(arr)) {\
                case NPY_DOUBLE: *(double *)(PyArray_DATA(arr))=*v; break;\
                case NPY_INT: *(int *)(PyArray_DATA(arr))=*v; break;\
                case NPY_LONG: *(long *)(PyArray_DATA(arr))=*v; break;\
                case NPY_FLOAT: *(float *)(PyArray_DATA(arr))=*v; break;\
                case NPY_CDOUBLE: *(double *)(PyArray_DATA(arr))=*v; break;\
                case NPY_CFLOAT: *(float *)(PyArray_DATA(arr))=*v; break;\
                case NPY_BOOL: *(npy_bool *)(PyArray_DATA(arr))=(*v!=0); break;\
                case NPY_UBYTE: *(unsigned char *)(PyArray_DATA(arr))=*v; break;\
                case NPY_BYTE: *(signed char *)(PyArray_DATA(arr))=*v; break;\
                case NPY_SHORT: *(short *)(PyArray_DATA(arr))=*v; break;\
                case NPY_USHORT: *(npy_ushort *)(PyArray_DATA(arr))=*v; break;\
                case NPY_UINT: *(npy_uint *)(PyArray_DATA(arr))=*v; break;\
                case NPY_ULONG: *(npy_ulong *)(PyArray_DATA(arr))=*v; break;\
                case NPY_LONGLONG: *(npy_longlong *)(PyArray_DATA(arr))=*v; break;\
                case NPY_ULONGLONG: *(npy_ulonglong *)(PyArray_DATA(arr))=*v; break;\
                case NPY_LONGDOUBLE: *(npy_longdouble *)(PyArray_DATA(arr))=*v; break;\
                case NPY_CLONGDOUBLE: *(npy_longdouble *)(PyArray_DATA(arr))=*v; break;\
                case NPY_OBJECT: PyArray_SETITEM(arr, PyArray_DATA(arr), pyobj_from_ ## ctype ## 1(*v)); break;\
        default: return -2;\
        };\
        return 1


/************************ See f2py2e/cfuncs.py: cfuncs ************************/
static int f2py_size(PyArrayObject* var, ...)
{
  npy_int sz = 0;
  npy_int dim;
  npy_int rank;
  va_list argp;
  va_start(argp, var);
  dim = va_arg(argp, npy_int);
  if (dim==-1)
    {
      sz = PyArray_SIZE(var);
    }
  else
    {
      rank = PyArray_NDIM(var);
      if (dim>=1 && dim<=rank)
        sz = PyArray_DIM(var, dim-1);
      else
        fprintf(stderr, "f2py_size: 2nd argument value=%d fails to satisfy 1<=value<=%d. Result will be 0.\n", dim, rank);
    }
  va_end(argp);
  return sz;
}

static int int_from_pyobj(int* v,PyObject *obj,const char *errmess) {
    PyObject* tmp = NULL;
    if (PyInt_Check(obj)) {
        *v = (int)PyInt_AS_LONG(obj);
        return 1;
    }
    tmp = PyNumber_Int(obj);
    if (tmp) {
        *v = PyInt_AS_LONG(tmp);
        Py_DECREF(tmp);
        return 1;
    }
    if (PyComplex_Check(obj))
        tmp = PyObject_GetAttrString(obj,"real");
    else if (PyString_Check(obj) || PyUnicode_Check(obj))
        /*pass*/;
    else if (PySequence_Check(obj))
        tmp = PySequence_GetItem(obj,0);
    if (tmp) {
        PyErr_Clear();
        if (int_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = _main_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}

static int try_pyarr_from_double(PyObject* obj,double* v) {
    TRYPYARRAYTEMPLATE(double,'d');
}

static int double_from_pyobj(double* v,PyObject *obj,const char *errmess) {
    PyObject* tmp = NULL;
    if (PyFloat_Check(obj)) {
#ifdef __sgi
        *v = PyFloat_AsDouble(obj);
#else
        *v = PyFloat_AS_DOUBLE(obj);
#endif
        return 1;
    }
    tmp = PyNumber_Float(obj);
    if (tmp) {
#ifdef __sgi
        *v = PyFloat_AsDouble(tmp);
#else
        *v = PyFloat_AS_DOUBLE(tmp);
#endif
        Py_DECREF(tmp);
        return 1;
    }
    if (PyComplex_Check(obj))
        tmp = PyObject_GetAttrString(obj,"real");
    else if (PyString_Check(obj) || PyUnicode_Check(obj))
        /*pass*/;
    else if (PySequence_Check(obj))
        tmp = PySequence_GetItem(obj,0);
    if (tmp) {
        PyErr_Clear();
        if (double_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = _main_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}

static int create_cb_arglist(PyObject* fun,PyTupleObject* xa,const int maxnofargs,const int nofoptargs,int *nofargs,PyTupleObject **args,const char *errmess) {
    PyObject *tmp = NULL;
    PyObject *tmp_fun = NULL;
    int tot,opt,ext,siz,i,di=0;
    CFUNCSMESS("create_cb_arglist\n");
    tot=opt=ext=siz=0;
    /* Get the total number of arguments */
    if (PyFunction_Check(fun)) {
        tmp_fun = fun;
        Py_INCREF(tmp_fun);
    }
    else {
        di = 1;
        if (PyObject_HasAttrString(fun,"im_func")) {
            tmp_fun = PyObject_GetAttrString(fun,"im_func");
        }
        else if (PyObject_HasAttrString(fun,"__call__")) {
            tmp = PyObject_GetAttrString(fun,"__call__");
            if (PyObject_HasAttrString(tmp,"im_func"))
                tmp_fun = PyObject_GetAttrString(tmp,"im_func");
            else {
                tmp_fun = fun; /* built-in function */
                Py_INCREF(tmp_fun);
                tot = maxnofargs;
                if (PyCFunction_Check(fun)) {
                    /* In case the function has a co_argcount (like on PyPy) */
                    di = 0;
                }
                if (xa != NULL)
                    tot += PyTuple_Size((PyObject *)xa);
            }
            Py_XDECREF(tmp);
        }
        else if (PyFortran_Check(fun) || PyFortran_Check1(fun)) {
            tot = maxnofargs;
            if (xa != NULL)
                tot += PyTuple_Size((PyObject *)xa);
            tmp_fun = fun;
            Py_INCREF(tmp_fun);
        }
        else if (F2PyCapsule_Check(fun)) {
            tot = maxnofargs;
            if (xa != NULL)
                ext = PyTuple_Size((PyObject *)xa);
            if(ext>0) {
                fprintf(stderr,"extra arguments tuple cannot be used with CObject call-back\n");
                goto capi_fail;
            }
            tmp_fun = fun;
            Py_INCREF(tmp_fun);
        }
    }
if (tmp_fun==NULL) {
fprintf(stderr,"Call-back argument must be function|instance|instance.__call__|f2py-function but got %s.\n",(fun==NULL?"NULL":Py_TYPE(fun)->tp_name));
goto capi_fail;
}
    if (PyObject_HasAttrString(tmp_fun,"__code__")) {
        if (PyObject_HasAttrString(tmp = PyObject_GetAttrString(tmp_fun,"__code__"),"co_argcount")) {
            PyObject *tmp_argcount = PyObject_GetAttrString(tmp,"co_argcount");
            Py_DECREF(tmp);
            if (tmp_argcount == NULL) {
                goto capi_fail;
            }
            tot = PyInt_AsLong(tmp_argcount) - di;
            Py_DECREF(tmp_argcount);
        }
    }
    /* Get the number of optional arguments */
    if (PyObject_HasAttrString(tmp_fun,"__defaults__")) {
        if (PyTuple_Check(tmp = PyObject_GetAttrString(tmp_fun,"__defaults__")))
            opt = PyTuple_Size(tmp);
        Py_XDECREF(tmp);
    }
    /* Get the number of extra arguments */
    if (xa != NULL)
        ext = PyTuple_Size((PyObject *)xa);
    /* Calculate the size of call-backs argument list */
    siz = MIN(maxnofargs+ext,tot);
    *nofargs = MAX(0,siz-ext);
#ifdef DEBUGCFUNCS
    fprintf(stderr,"debug-capi:create_cb_arglist:maxnofargs(-nofoptargs),tot,opt,ext,siz,nofargs=%d(-%d),%d,%d,%d,%d,%d\n",maxnofargs,nofoptargs,tot,opt,ext,siz,*nofargs);
#endif
    if (siz<tot-opt) {
        fprintf(stderr,"create_cb_arglist: Failed to build argument list (siz) with enough arguments (tot-opt) required by user-supplied function (siz,tot,opt=%d,%d,%d).\n",siz,tot,opt);
        goto capi_fail;
    }
    /* Initialize argument list */
    *args = (PyTupleObject *)PyTuple_New(siz);
    for (i=0;i<*nofargs;i++) {
        Py_INCREF(Py_None);
        PyTuple_SET_ITEM((PyObject *)(*args),i,Py_None);
    }
    if (xa != NULL)
        for (i=(*nofargs);i<siz;i++) {
            tmp = PyTuple_GetItem((PyObject *)xa,i-(*nofargs));
            Py_INCREF(tmp);
            PyTuple_SET_ITEM(*args,i,tmp);
        }
    CFUNCSMESS("create_cb_arglist-end\n");
    Py_DECREF(tmp_fun);
    return 1;
capi_fail:
    if ((PyErr_Occurred())==NULL)
        PyErr_SetString(_main_error,errmess);
    Py_XDECREF(tmp_fun);
    return 0;
}


/********************* See f2py2e/cfuncs.py: userincludes *********************/
/*need_userincludes*/

/********************* See f2py2e/capi_rules.py: usercode *********************/


/* See f2py2e/rules.py */
extern void F_FUNC_US(random_init,RANDOM_INIT)(void);
extern void F_FUNC_US(random_init_seed,RANDOM_INIT_SEED)(int*);
extern void F_FUNC(random,RANDOM)(double*);
extern void F_FUNC(randomn,RANDOMN)(double*);
extern void F_FUNC(rfft,RFFT)(double*,int*);
extern void F_FUNC(irfft,IRFFT)(double*,int*);
/*eof externroutines*/

/******************** See f2py2e/capi_rules.py: usercode1 ********************/


/******************* See f2py2e/cb_rules.py: buildcallback *******************/

/******************* cb_potential_in__main__user__routines *******************/
PyObject *cb_potential_in__main__user__routines_capi = NULL;/*was Py_None*/
PyTupleObject *cb_potential_in__main__user__routines_args_capi = NULL;
int cb_potential_in__main__user__routines_nofargs = 0;
jmp_buf cb_potential_in__main__user__routines_jmpbuf;
/*typedef void(*cb_potential_in__main__user__routines_typedef)(double *,double *,double *,int *,int *,int *);*/
static void cb_potential_in__main__user__routines (double *q,double *v,double *dvdq,int *natoms_cb_capi,int *nbeads_cb_capi,int *info_cb_capi) {
  PyTupleObject *capi_arglist = cb_potential_in__main__user__routines_args_capi;
  PyObject *capi_return = NULL;
  PyObject *capi_tmp = NULL;
  PyObject *capi_arglist_list = NULL;
  int capi_j,capi_i = 0;
  int capi_longjmp_ok = 1;
/*decl*/
  int natoms=(*natoms_cb_capi);
  int nbeads=(*nbeads_cb_capi);
  int info=(*info_cb_capi);
  npy_intp q_Dims[3] = {-1, -1, -1};
  npy_intp v_Dims[1] = {-1};
  npy_intp dvdq_Dims[3] = {-1, -1, -1};
#ifdef F2PY_REPORT_ATEXIT
f2py_cb_start_clock();
#endif
  CFUNCSMESS("cb:Call-back function cb_potential_in__main__user__routines (maxnofargs=3(-2))\n");
  CFUNCSMESSPY("cb:cb_potential_in__main__user__routines_capi=",cb_potential_in__main__user__routines_capi);
  if (cb_potential_in__main__user__routines_capi==NULL) {
    capi_longjmp_ok = 0;
    cb_potential_in__main__user__routines_capi = PyObject_GetAttrString(_main_module,"potential");
  }
  if (cb_potential_in__main__user__routines_capi==NULL) {
    PyErr_SetString(_main_error,"cb: Callback potential not defined (as an argument or module _main attribute).\n");
    goto capi_fail;
  }
  if (F2PyCapsule_Check(cb_potential_in__main__user__routines_capi)) {
  cb_potential_in__main__user__routines_typedef cb_potential_in__main__user__routines_cptr;
  cb_potential_in__main__user__routines_cptr = F2PyCapsule_AsVoidPtr(cb_potential_in__main__user__routines_capi);
  (*cb_potential_in__main__user__routines_cptr)(q,v,dvdq,natoms_cb_capi,nbeads_cb_capi,info_cb_capi);
  return;
  }
  if (capi_arglist==NULL) {
    capi_longjmp_ok = 0;
    capi_tmp = PyObject_GetAttrString(_main_module,"potential_extra_args");
    if (capi_tmp) {
      capi_arglist = (PyTupleObject *)PySequence_Tuple(capi_tmp);
      if (capi_arglist==NULL) {
        PyErr_SetString(_main_error,"Failed to convert _main.potential_extra_args to tuple.\n");
        goto capi_fail;
      }
    } else {
      PyErr_Clear();
      capi_arglist = (PyTupleObject *)Py_BuildValue("()");
    }
  }
  if (capi_arglist == NULL) {
    PyErr_SetString(_main_error,"Callback potential argument list is not set.\n");
    goto capi_fail;
  }
/*setdims*/
  q_Dims[0]=3,q_Dims[1]=natoms,q_Dims[2]=nbeads;
  v_Dims[0]=nbeads;
  dvdq_Dims[0]=3,dvdq_Dims[1]=natoms,dvdq_Dims[2]=nbeads;
#ifdef PYPY_VERSION
#define CAPI_ARGLIST_SETITEM(idx, value) PyList_SetItem((PyObject *)capi_arglist_list, idx, value)
  capi_arglist_list = PySequence_List(capi_arglist);
  if (capi_arglist_list == NULL) goto capi_fail;
#else
#define CAPI_ARGLIST_SETITEM(idx, value) PyTuple_SetItem((PyObject *)capi_arglist, idx, value)
#endif
/*pyobjfrom*/
  if (cb_potential_in__main__user__routines_nofargs>capi_i) {
    int itemsize_ = NPY_DOUBLE == NPY_STRING ? 1 : 0;
    /*XXX: Hmm, what will destroy this array??? */
    PyArrayObject *tmp_arr = (PyArrayObject *)PyArray_New(&PyArray_Type,3,q_Dims,NPY_DOUBLE,NULL,(char*)q,itemsize_,NPY_ARRAY_FARRAY,NULL);


    if (tmp_arr==NULL)
      goto capi_fail;
    if (CAPI_ARGLIST_SETITEM(capi_i++,(PyObject *)tmp_arr))
      goto capi_fail;
}
  if (cb_potential_in__main__user__routines_nofargs>capi_i)
    if (CAPI_ARGLIST_SETITEM(capi_i++,pyobj_from_int1(natoms)))
      goto capi_fail;
  if (cb_potential_in__main__user__routines_nofargs>capi_i)
    if (CAPI_ARGLIST_SETITEM(capi_i++,pyobj_from_int1(nbeads)))
      goto capi_fail;
#undef CAPI_ARGLIST_SETITEM
#ifdef PYPY_VERSION
  CFUNCSMESSPY("cb:capi_arglist=",capi_arglist_list);
#else
  CFUNCSMESSPY("cb:capi_arglist=",capi_arglist);
#endif
  CFUNCSMESS("cb:Call-back calling Python function potential.\n");
#ifdef F2PY_REPORT_ATEXIT
f2py_cb_start_call_clock();
#endif
#ifdef PYPY_VERSION
  capi_return = PyObject_CallObject(cb_potential_in__main__user__routines_capi,(PyObject *)capi_arglist_list);
  Py_DECREF(capi_arglist_list);
  capi_arglist_list = NULL;
#else
  capi_return = PyObject_CallObject(cb_potential_in__main__user__routines_capi,(PyObject *)capi_arglist);
#endif
#ifdef F2PY_REPORT_ATEXIT
f2py_cb_stop_call_clock();
#endif
  CFUNCSMESSPY("cb:capi_return=",capi_return);
  if (capi_return == NULL) {
    fprintf(stderr,"capi_return is NULL\n");
    goto capi_fail;
  }
  if (capi_return == Py_None) {
    Py_DECREF(capi_return);
    capi_return = Py_BuildValue("()");
  }
  else if (!PyTuple_Check(capi_return)) {
    capi_return = Py_BuildValue("(N)",capi_return);
  }
  capi_j = PyTuple_Size(capi_return);
  capi_i = 0;
/*frompyobj*/
  if (capi_j>capi_i) {
    PyArrayObject *rv_cb_arr = NULL;
    if ((capi_tmp = PyTuple_GetItem(capi_return,capi_i++))==NULL) goto capi_fail;
    rv_cb_arr =  array_from_pyobj(NPY_DOUBLE,v_Dims,1,F2PY_INTENT_IN
,capi_tmp);
    if (rv_cb_arr == NULL) {
      fprintf(stderr,"rv_cb_arr is NULL\n");
      goto capi_fail;
    }
    MEMCOPY(v,PyArray_DATA(rv_cb_arr),PyArray_NBYTES(rv_cb_arr));
    if (capi_tmp != (PyObject *)rv_cb_arr) {
      Py_DECREF(rv_cb_arr);
    }
  }
  if (capi_j>capi_i) {
    PyArrayObject *rv_cb_arr = NULL;
    if ((capi_tmp = PyTuple_GetItem(capi_return,capi_i++))==NULL) goto capi_fail;
    rv_cb_arr =  array_from_pyobj(NPY_DOUBLE,dvdq_Dims,3,F2PY_INTENT_IN
,capi_tmp);
    if (rv_cb_arr == NULL) {
      fprintf(stderr,"rv_cb_arr is NULL\n");
      goto capi_fail;
    }
    MEMCOPY(dvdq,PyArray_DATA(rv_cb_arr),PyArray_NBYTES(rv_cb_arr));
    if (capi_tmp != (PyObject *)rv_cb_arr) {
      Py_DECREF(rv_cb_arr);
    }
  }
  if (capi_j>capi_i)
    GETSCALARFROMPYTUPLE(capi_return,capi_i++,info_cb_capi,int,"int_from_pyobj failed in converting argument info of call-back function cb_potential_in__main__user__routines to C int\n");
  CFUNCSMESS("cb:cb_potential_in__main__user__routines:successful\n");
  Py_DECREF(capi_return);
#ifdef F2PY_REPORT_ATEXIT
f2py_cb_stop_clock();
#endif
  goto capi_return_pt;
capi_fail:
  fprintf(stderr,"Call-back cb_potential_in__main__user__routines failed.\n");
  Py_XDECREF(capi_return);
  Py_XDECREF(capi_arglist_list);
  if (capi_longjmp_ok)
    longjmp(cb_potential_in__main__user__routines_jmpbuf,-1);
capi_return_pt:
  ;
return;
}
/**************** end of cb_potential_in__main__user__routines ****************/


/*********************** See f2py2e/rules.py: buildapi ***********************/

/******************************** random_init ********************************/
static char doc_f2py_rout__main_random_init[] = "\
random_init()\n\nWrapper for ``random_init``.\
\n";
/* extern void F_FUNC_US(random_init,RANDOM_INIT)(void); */
static PyObject *f2py_rout__main_random_init(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "|:_main.random_init",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of random_init *****************************/

/****************************** random_init_seed ******************************/
static char doc_f2py_rout__main_random_init_seed[] = "\
random_init_seed(value)\n\nWrapper for ``random_init_seed``.\
\n\nParameters\n----------\n"
"value : input int";
/* extern void F_FUNC_US(random_init_seed,RANDOM_INIT_SEED)(int*); */
static PyObject *f2py_rout__main_random_init_seed(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int value = 0;
  PyObject *value_capi = Py_None;
  static char *capi_kwlist[] = {"value",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|:_main.random_init_seed",\
    capi_kwlist,&value_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable value */
    f2py_success = int_from_pyobj(&value,value_capi,"_main.random_init_seed() 1st argument (value) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&value);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of value*/
  /* End of cleaning variable value */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of random_init_seed **************************/

/*********************************** random ***********************************/
static char doc_f2py_rout__main_random[] = "\
rn = random()\n\nWrapper for ``random``.\
\n\nReturns\n-------\n"
"rn : float";
/* extern void F_FUNC(random,RANDOM)(double*); */
static PyObject *f2py_rout__main_random(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double rn = 0;
  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "|:_main.random",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
  /* Processing variable rn */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&rn);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",rn);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable rn */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of random *******************************/

/********************************** randomn **********************************/
static char doc_f2py_rout__main_randomn[] = "\
rn = randomn()\n\nWrapper for ``randomn``.\
\n\nReturns\n-------\n"
"rn : float";
/* extern void F_FUNC(randomn,RANDOMN)(double*); */
static PyObject *f2py_rout__main_randomn(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double rn = 0;
  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "|:_main.randomn",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
  /* Processing variable rn */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&rn);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",rn);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable rn */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of randomn *******************************/

/************************************ rfft ************************************/
static char doc_f2py_rout__main_rfft[] = "\
rfft(x,[n])\n\nWrapper for ``rfft``.\
\n\nParameters\n----------\n"
"x : in/output rank-1 array('d') with bounds (n)\n"
"\nOther Parameters\n----------------\n"
"n : input int, optional\n    Default: len(x)";
/* extern void F_FUNC(rfft,RFFT)(double*,int*); */
static PyObject *f2py_rout__main_rfft(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  static char *capi_kwlist[] = {"x","n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.rfft",\
    capi_kwlist,&x_capi,&n_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable x */
  ;
  capi_x_intent |= F2PY_INTENT_INOUT;
  capi_x_tmp = array_from_pyobj(NPY_DOUBLE,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `x' of _main.rfft to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    x = (double *)(PyArray_DATA(capi_x_tmp));

  /* Processing variable n */
  if (n_capi == Py_None) n = len(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_main.rfft() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(x)>=n,"len(x)>=n","1st keyword n","rfft:n=%d",n) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,&n);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(x)>=n)*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  if((PyObject *)capi_x_tmp!=x_capi) {
    Py_XDECREF(capi_x_tmp); }
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of rfft ********************************/

/*********************************** irfft ***********************************/
static char doc_f2py_rout__main_irfft[] = "\
irfft(x,[n])\n\nWrapper for ``irfft``.\
\n\nParameters\n----------\n"
"x : in/output rank-1 array('d') with bounds (n)\n"
"\nOther Parameters\n----------------\n"
"n : input int, optional\n    Default: len(x)";
/* extern void F_FUNC(irfft,IRFFT)(double*,int*); */
static PyObject *f2py_rout__main_irfft(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *x = NULL;
  npy_intp x_Dims[1] = {-1};
  const int x_Rank = 1;
  PyArrayObject *capi_x_tmp = NULL;
  int capi_x_intent = 0;
  PyObject *x_capi = Py_None;
  int n = 0;
  PyObject *n_capi = Py_None;
  static char *capi_kwlist[] = {"x","n",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.irfft",\
    capi_kwlist,&x_capi,&n_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable x */
  ;
  capi_x_intent |= F2PY_INTENT_INOUT;
  capi_x_tmp = array_from_pyobj(NPY_DOUBLE,x_Dims,x_Rank,capi_x_intent,x_capi);
  if (capi_x_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `x' of _main.irfft to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    x = (double *)(PyArray_DATA(capi_x_tmp));

  /* Processing variable n */
  if (n_capi == Py_None) n = len(x); else
    f2py_success = int_from_pyobj(&n,n_capi,"_main.irfft() 1st keyword (n) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(x)>=n,"len(x)>=n","1st keyword n","irfft:n=%d",n) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(x,&n);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(len(x)>=n)*/
  } /*if (f2py_success) of n*/
  /* End of cleaning variable n */
  if((PyObject *)capi_x_tmp!=x_capi) {
    Py_XDECREF(capi_x_tmp); }
  }  /*if (capi_x_tmp == NULL) ... else of x*/
  /* End of cleaning variable x */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of irfft ********************************/

/******************************** equilibrate ********************************/
static char doc_f2py_rout__main_system_equilibrate[] = "\
result = equilibrate(t,p,q,steps,xi_current,potential,kforce,constrain,save_trajectory,[natoms,nbeads,potential_extra_args])\n\nWrapper for ``equilibrate``.\
\n\nParameters\n----------\n"
"t : in/output rank-0 array(float,'d')\n"
"p : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"q : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"steps : input int\n"
"xi_current : input float\n"
"potential : call-back function\n"
"kforce : input float\n"
"constrain : input int\n"
"save_trajectory : input int\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(p,1)\n"
"nbeads : input int, optional\n    Default: shape(p,2)\n"
"potential_extra_args : input tuple, optional\n    Default: ()\n"
"\nReturns\n-------\n"
"result : int\n"
"\nNotes\n-----\nCall-back functions::\n\n"
"  def potential(q,[natoms,nbeads]): return v,dvdq,info\n\
  Required arguments:\n"
"    q : input rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"  Optional arguments:\n"
"    natoms : input int, optional\n    Default: shape(q,1)\n"
"    nbeads : input int, optional\n    Default: shape(q,2)\n"
"  Return objects:\n"
"    v : rank-1 array('d') with bounds (nbeads)\n"
"    dvdq : rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"    info : int";
/*  */
static PyObject *f2py_rout__main_system_equilibrate(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*,int*,int*,double*,cb_potential_in__main__user__routines_typedef,double*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double t = 0;
  PyObject *t_capi = Py_None;
  double *p = NULL;
  npy_intp p_Dims[3] = {-1, -1, -1};
  const int p_Rank = 3;
  PyArrayObject *capi_p_tmp = NULL;
  int capi_p_intent = 0;
  PyObject *p_capi = Py_None;
  double *q = NULL;
  npy_intp q_Dims[3] = {-1, -1, -1};
  const int q_Rank = 3;
  PyArrayObject *capi_q_tmp = NULL;
  int capi_q_intent = 0;
  PyObject *q_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  int steps = 0;
  PyObject *steps_capi = Py_None;
  double xi_current = 0;
  PyObject *xi_current_capi = Py_None;
  PyObject *potential_capi = Py_None;
  PyTupleObject *potential_xa_capi = NULL;
  PyTupleObject *potential_args_capi = NULL;
  int potential_nofargs_capi = 0;
  cb_potential_in__main__user__routines_typedef potential_cptr;
  double kforce = 0;
  PyObject *kforce_capi = Py_None;
  int constrain = 0;
  PyObject *constrain_capi = Py_None;
  int save_trajectory = 0;
  PyObject *save_trajectory_capi = Py_None;
  int result = 0;
  static char *capi_kwlist[] = {"t","p","q","steps","xi_current","potential","kforce","constrain","save_trajectory","natoms","nbeads","potential_extra_args",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOOOOO|OOO!:_main.system.equilibrate",\
    capi_kwlist,&t_capi,&p_capi,&q_capi,&steps_capi,&xi_current_capi,&potential_capi,&kforce_capi,&constrain_capi,&save_trajectory_capi,&natoms_capi,&nbeads_capi,&PyTuple_Type,&potential_xa_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable t */
    f2py_success = double_from_pyobj(&t,t_capi,"_main.system.equilibrate() 1st argument (t) can't be converted to double");
  if (f2py_success) {
  /* Processing variable p */
  p_Dims[0]=3;
  capi_p_intent |= F2PY_INTENT_INOUT;
  capi_p_tmp = array_from_pyobj(NPY_DOUBLE,p_Dims,p_Rank,capi_p_intent,p_capi);
  if (capi_p_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 2nd argument `p' of _main.system.equilibrate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    p = (double *)(PyArray_DATA(capi_p_tmp));

  /* Processing variable steps */
    f2py_success = int_from_pyobj(&steps,steps_capi,"_main.system.equilibrate() 4th argument (steps) can't be converted to int");
  if (f2py_success) {
  /* Processing variable xi_current */
    f2py_success = double_from_pyobj(&xi_current,xi_current_capi,"_main.system.equilibrate() 5th argument (xi_current) can't be converted to double");
  if (f2py_success) {
  /* Processing variable potential */
if(F2PyCapsule_Check(potential_capi)) {
  potential_cptr = F2PyCapsule_AsVoidPtr(potential_capi);
} else {
  potential_cptr = cb_potential_in__main__user__routines;
}

  potential_nofargs_capi = cb_potential_in__main__user__routines_nofargs;
  if (create_cb_arglist(potential_capi,potential_xa_capi,3,2,&cb_potential_in__main__user__routines_nofargs,&potential_args_capi,"failed in processing argument list for call-back potential.")) {
    jmp_buf potential_jmpbuf;
    CFUNCSMESS("Saving jmpbuf for `potential`.\n");
    SWAP(potential_capi,cb_potential_in__main__user__routines_capi,PyObject);
    SWAP(potential_args_capi,cb_potential_in__main__user__routines_args_capi,PyTupleObject);
    memcpy(&potential_jmpbuf,&cb_potential_in__main__user__routines_jmpbuf,sizeof(jmp_buf));
  /* Processing variable kforce */
    f2py_success = double_from_pyobj(&kforce,kforce_capi,"_main.system.equilibrate() 7th argument (kforce) can't be converted to double");
  if (f2py_success) {
  /* Processing variable constrain */
    f2py_success = int_from_pyobj(&constrain,constrain_capi,"_main.system.equilibrate() 8th argument (constrain) can't be converted to int");
  if (f2py_success) {
  /* Processing variable save_trajectory */
    f2py_success = int_from_pyobj(&save_trajectory,save_trajectory_capi,"_main.system.equilibrate() 9th argument (save_trajectory) can't be converted to int");
  if (f2py_success) {
  /* Processing variable result */
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(p,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.equilibrate() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,1)==natoms,"shape(p,1)==natoms","1st keyword natoms","equilibrate:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(p,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.equilibrate() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,2)==nbeads,"shape(p,2)==nbeads","2nd keyword nbeads","equilibrate:nbeads=%d",nbeads) {
  /* Processing variable q */
  q_Dims[0]=3,q_Dims[1]=natoms,q_Dims[2]=nbeads;
  capi_q_intent |= F2PY_INTENT_INOUT;
  capi_q_tmp = array_from_pyobj(NPY_DOUBLE,q_Dims,q_Rank,capi_q_intent,q_capi);
  if (capi_q_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 3rd argument `q' of _main.system.equilibrate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    q = (double *)(PyArray_DATA(capi_q_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
    if ((setjmp(cb_potential_in__main__user__routines_jmpbuf))) {
      f2py_success = 0;
    } else {
        (*f2py_func)(&t,p,q,&natoms,&nbeads,&steps,&xi_current,potential_cptr,&kforce,&constrain,&save_trajectory,&result);
    }
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
  f2py_success = try_pyarr_from_double(t_capi,&t);
  if (f2py_success) {
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("i",result);
/*closepyobjfrom*/
  } /*if (f2py_success) of t pyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_q_tmp!=q_capi) {
    Py_XDECREF(capi_q_tmp); }
  }  /*if (capi_q_tmp == NULL) ... else of q*/
  /* End of cleaning variable q */
  } /*CHECKSCALAR(shape(p,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(p,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  /* End of cleaning variable result */
  } /*if (f2py_success) of save_trajectory*/
  /* End of cleaning variable save_trajectory */
  } /*if (f2py_success) of constrain*/
  /* End of cleaning variable constrain */
  } /*if (f2py_success) of kforce*/
  /* End of cleaning variable kforce */
    CFUNCSMESS("Restoring jmpbuf for `potential`.\n");
    cb_potential_in__main__user__routines_capi = potential_capi;
    Py_DECREF(cb_potential_in__main__user__routines_args_capi);
    cb_potential_in__main__user__routines_args_capi = potential_args_capi;
    cb_potential_in__main__user__routines_nofargs = potential_nofargs_capi;
    memcpy(&cb_potential_in__main__user__routines_jmpbuf,&potential_jmpbuf,sizeof(jmp_buf));
  }
  /* End of cleaning variable potential */
  } /*if (f2py_success) of xi_current*/
  /* End of cleaning variable xi_current */
  } /*if (f2py_success) of steps*/
  /* End of cleaning variable steps */
  if((PyObject *)capi_p_tmp!=p_capi) {
    Py_XDECREF(capi_p_tmp); }
  }  /*if (capi_p_tmp == NULL) ... else of p*/
  /* End of cleaning variable p */
  } /*if (f2py_success) of t*/
  /* End of cleaning variable t */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of equilibrate *****************************/

/*************************** recrossing_trajectory ***************************/
static char doc_f2py_rout__main_system_recrossing_trajectory[] = "\
result = recrossing_trajectory(t,p,q,xi_current,potential,save_trajectory,kappa_num,kappa_denom,cor,[natoms,nbeads,steps,potential_extra_args])\n\nWrapper for ``recrossing_trajectory``.\
\n\nParameters\n----------\n"
"t : in/output rank-0 array(float,'d')\n"
"p : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"q : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"xi_current : input float\n"
"potential : call-back function\n"
"save_trajectory : input int\n"
"kappa_num : in/output rank-1 array('d') with bounds (steps)\n"
"kappa_denom : in/output rank-0 array(float,'d')\n"
"cor : input int\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(p,1)\n"
"nbeads : input int, optional\n    Default: shape(p,2)\n"
"steps : input int, optional\n    Default: len(kappa_num)\n"
"potential_extra_args : input tuple, optional\n    Default: ()\n"
"\nReturns\n-------\n"
"result : int\n"
"\nNotes\n-----\nCall-back functions::\n\n"
"  def potential(q,[natoms,nbeads]): return v,dvdq,info\n\
  Required arguments:\n"
"    q : input rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"  Optional arguments:\n"
"    natoms : input int, optional\n    Default: shape(q,1)\n"
"    nbeads : input int, optional\n    Default: shape(q,2)\n"
"  Return objects:\n"
"    v : rank-1 array('d') with bounds (nbeads)\n"
"    dvdq : rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"    info : int";
/*  */
static PyObject *f2py_rout__main_system_recrossing_trajectory(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*,int*,int*,double*,cb_potential_in__main__user__routines_typedef,int*,double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double t = 0;
  PyObject *t_capi = Py_None;
  double *p = NULL;
  npy_intp p_Dims[3] = {-1, -1, -1};
  const int p_Rank = 3;
  PyArrayObject *capi_p_tmp = NULL;
  int capi_p_intent = 0;
  PyObject *p_capi = Py_None;
  double *q = NULL;
  npy_intp q_Dims[3] = {-1, -1, -1};
  const int q_Rank = 3;
  PyArrayObject *capi_q_tmp = NULL;
  int capi_q_intent = 0;
  PyObject *q_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  int steps = 0;
  PyObject *steps_capi = Py_None;
  double xi_current = 0;
  PyObject *xi_current_capi = Py_None;
  PyObject *potential_capi = Py_None;
  PyTupleObject *potential_xa_capi = NULL;
  PyTupleObject *potential_args_capi = NULL;
  int potential_nofargs_capi = 0;
  cb_potential_in__main__user__routines_typedef potential_cptr;
  int save_trajectory = 0;
  PyObject *save_trajectory_capi = Py_None;
  double *kappa_num = NULL;
  npy_intp kappa_num_Dims[1] = {-1};
  const int kappa_num_Rank = 1;
  PyArrayObject *capi_kappa_num_tmp = NULL;
  int capi_kappa_num_intent = 0;
  PyObject *kappa_num_capi = Py_None;
  double kappa_denom = 0;
  PyObject *kappa_denom_capi = Py_None;
  int result = 0;
  int cor = 0;
  PyObject *cor_capi = Py_None;
  static char *capi_kwlist[] = {"t","p","q","xi_current","potential","save_trajectory","kappa_num","kappa_denom","cor","natoms","nbeads","steps","potential_extra_args",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOOOOO|OOOO!:_main.system.recrossing_trajectory",\
    capi_kwlist,&t_capi,&p_capi,&q_capi,&xi_current_capi,&potential_capi,&save_trajectory_capi,&kappa_num_capi,&kappa_denom_capi,&cor_capi,&natoms_capi,&nbeads_capi,&steps_capi,&PyTuple_Type,&potential_xa_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable t */
    f2py_success = double_from_pyobj(&t,t_capi,"_main.system.recrossing_trajectory() 1st argument (t) can't be converted to double");
  if (f2py_success) {
  /* Processing variable p */
  p_Dims[0]=3;
  capi_p_intent |= F2PY_INTENT_INOUT;
  capi_p_tmp = array_from_pyobj(NPY_DOUBLE,p_Dims,p_Rank,capi_p_intent,p_capi);
  if (capi_p_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 2nd argument `p' of _main.system.recrossing_trajectory to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    p = (double *)(PyArray_DATA(capi_p_tmp));

  /* Processing variable xi_current */
    f2py_success = double_from_pyobj(&xi_current,xi_current_capi,"_main.system.recrossing_trajectory() 4th argument (xi_current) can't be converted to double");
  if (f2py_success) {
  /* Processing variable potential */
if(F2PyCapsule_Check(potential_capi)) {
  potential_cptr = F2PyCapsule_AsVoidPtr(potential_capi);
} else {
  potential_cptr = cb_potential_in__main__user__routines;
}

  potential_nofargs_capi = cb_potential_in__main__user__routines_nofargs;
  if (create_cb_arglist(potential_capi,potential_xa_capi,3,2,&cb_potential_in__main__user__routines_nofargs,&potential_args_capi,"failed in processing argument list for call-back potential.")) {
    jmp_buf potential_jmpbuf;
    CFUNCSMESS("Saving jmpbuf for `potential`.\n");
    SWAP(potential_capi,cb_potential_in__main__user__routines_capi,PyObject);
    SWAP(potential_args_capi,cb_potential_in__main__user__routines_args_capi,PyTupleObject);
    memcpy(&potential_jmpbuf,&cb_potential_in__main__user__routines_jmpbuf,sizeof(jmp_buf));
  /* Processing variable save_trajectory */
    f2py_success = int_from_pyobj(&save_trajectory,save_trajectory_capi,"_main.system.recrossing_trajectory() 6th argument (save_trajectory) can't be converted to int");
  if (f2py_success) {
  /* Processing variable kappa_num */
  ;
  capi_kappa_num_intent |= F2PY_INTENT_INOUT;
  capi_kappa_num_tmp = array_from_pyobj(NPY_DOUBLE,kappa_num_Dims,kappa_num_Rank,capi_kappa_num_intent,kappa_num_capi);
  if (capi_kappa_num_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 7th argument `kappa_num' of _main.system.recrossing_trajectory to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    kappa_num = (double *)(PyArray_DATA(capi_kappa_num_tmp));

  /* Processing variable kappa_denom */
    f2py_success = double_from_pyobj(&kappa_denom,kappa_denom_capi,"_main.system.recrossing_trajectory() 8th argument (kappa_denom) can't be converted to double");
  if (f2py_success) {
  /* Processing variable result */
  /* Processing variable cor */
    f2py_success = int_from_pyobj(&cor,cor_capi,"_main.system.recrossing_trajectory() 9th argument (cor) can't be converted to int");
  if (f2py_success) {
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(p,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.recrossing_trajectory() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,1)==natoms,"shape(p,1)==natoms","1st keyword natoms","recrossing_trajectory:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(p,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.recrossing_trajectory() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,2)==nbeads,"shape(p,2)==nbeads","2nd keyword nbeads","recrossing_trajectory:nbeads=%d",nbeads) {
  /* Processing variable steps */
  if (steps_capi == Py_None) steps = len(kappa_num); else
    f2py_success = int_from_pyobj(&steps,steps_capi,"_main.system.recrossing_trajectory() 3rd keyword (steps) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(kappa_num)>=steps,"len(kappa_num)>=steps","3rd keyword steps","recrossing_trajectory:steps=%d",steps) {
  /* Processing variable q */
  q_Dims[0]=3,q_Dims[1]=natoms,q_Dims[2]=nbeads;
  capi_q_intent |= F2PY_INTENT_INOUT;
  capi_q_tmp = array_from_pyobj(NPY_DOUBLE,q_Dims,q_Rank,capi_q_intent,q_capi);
  if (capi_q_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 3rd argument `q' of _main.system.recrossing_trajectory to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    q = (double *)(PyArray_DATA(capi_q_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
    if ((setjmp(cb_potential_in__main__user__routines_jmpbuf))) {
      f2py_success = 0;
    } else {
        (*f2py_func)(&t,p,q,&natoms,&nbeads,&steps,&xi_current,potential_cptr,&save_trajectory,kappa_num,&kappa_denom,&result,&cor);
    }
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
  f2py_success = try_pyarr_from_double(t_capi,&t);
  if (f2py_success) {
  f2py_success = try_pyarr_from_double(kappa_denom_capi,&kappa_denom);
  if (f2py_success) {
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("i",result);
/*closepyobjfrom*/
  } /*if (f2py_success) of kappa_denom pyobjfrom*/
  } /*if (f2py_success) of t pyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_q_tmp!=q_capi) {
    Py_XDECREF(capi_q_tmp); }
  }  /*if (capi_q_tmp == NULL) ... else of q*/
  /* End of cleaning variable q */
  } /*CHECKSCALAR(len(kappa_num)>=steps)*/
  } /*if (f2py_success) of steps*/
  /* End of cleaning variable steps */
  } /*CHECKSCALAR(shape(p,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(p,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  } /*if (f2py_success) of cor*/
  /* End of cleaning variable cor */
  /* End of cleaning variable result */
  } /*if (f2py_success) of kappa_denom*/
  /* End of cleaning variable kappa_denom */
  if((PyObject *)capi_kappa_num_tmp!=kappa_num_capi) {
    Py_XDECREF(capi_kappa_num_tmp); }
  }  /*if (capi_kappa_num_tmp == NULL) ... else of kappa_num*/
  /* End of cleaning variable kappa_num */
  } /*if (f2py_success) of save_trajectory*/
  /* End of cleaning variable save_trajectory */
    CFUNCSMESS("Restoring jmpbuf for `potential`.\n");
    cb_potential_in__main__user__routines_capi = potential_capi;
    Py_DECREF(cb_potential_in__main__user__routines_args_capi);
    cb_potential_in__main__user__routines_args_capi = potential_args_capi;
    cb_potential_in__main__user__routines_nofargs = potential_nofargs_capi;
    memcpy(&cb_potential_in__main__user__routines_jmpbuf,&potential_jmpbuf,sizeof(jmp_buf));
  }
  /* End of cleaning variable potential */
  } /*if (f2py_success) of xi_current*/
  /* End of cleaning variable xi_current */
  if((PyObject *)capi_p_tmp!=p_capi) {
    Py_XDECREF(capi_p_tmp); }
  }  /*if (capi_p_tmp == NULL) ... else of p*/
  /* End of cleaning variable p */
  } /*if (f2py_success) of t*/
  /* End of cleaning variable t */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************ end of recrossing_trajectory ************************/

/**************************** umbrella_trajectory ****************************/
static char doc_f2py_rout__main_system_umbrella_trajectory[] = "\
av,av2,actual_steps,result = umbrella_trajectory(t,p,q,steps,xi_current,potential,kforce,xi_range,save_trajectory,[natoms,nbeads,potential_extra_args])\n\nWrapper for ``umbrella_trajectory``.\
\n\nParameters\n----------\n"
"t : in/output rank-0 array(float,'d')\n"
"p : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"q : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"steps : input int\n"
"xi_current : input float\n"
"potential : call-back function\n"
"kforce : input float\n"
"xi_range : input float\n"
"save_trajectory : input int\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(p,1)\n"
"nbeads : input int, optional\n    Default: shape(p,2)\n"
"potential_extra_args : input tuple, optional\n    Default: ()\n"
"\nReturns\n-------\n"
"av : float\n"
"av2 : float\n"
"actual_steps : int\n"
"result : int\n"
"\nNotes\n-----\nCall-back functions::\n\n"
"  def potential(q,[natoms,nbeads]): return v,dvdq,info\n\
  Required arguments:\n"
"    q : input rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"  Optional arguments:\n"
"    natoms : input int, optional\n    Default: shape(q,1)\n"
"    nbeads : input int, optional\n    Default: shape(q,2)\n"
"  Return objects:\n"
"    v : rank-1 array('d') with bounds (nbeads)\n"
"    dvdq : rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"    info : int";
/*  */
static PyObject *f2py_rout__main_system_umbrella_trajectory(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*,int*,int*,double*,cb_potential_in__main__user__routines_typedef,double*,double*,int*,double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double t = 0;
  PyObject *t_capi = Py_None;
  double *p = NULL;
  npy_intp p_Dims[3] = {-1, -1, -1};
  const int p_Rank = 3;
  PyArrayObject *capi_p_tmp = NULL;
  int capi_p_intent = 0;
  PyObject *p_capi = Py_None;
  double *q = NULL;
  npy_intp q_Dims[3] = {-1, -1, -1};
  const int q_Rank = 3;
  PyArrayObject *capi_q_tmp = NULL;
  int capi_q_intent = 0;
  PyObject *q_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  int steps = 0;
  PyObject *steps_capi = Py_None;
  double xi_current = 0;
  PyObject *xi_current_capi = Py_None;
  PyObject *potential_capi = Py_None;
  PyTupleObject *potential_xa_capi = NULL;
  PyTupleObject *potential_args_capi = NULL;
  int potential_nofargs_capi = 0;
  cb_potential_in__main__user__routines_typedef potential_cptr;
  double kforce = 0;
  PyObject *kforce_capi = Py_None;
  double xi_range = 0;
  PyObject *xi_range_capi = Py_None;
  int save_trajectory = 0;
  PyObject *save_trajectory_capi = Py_None;
  double av = 0;
  double av2 = 0;
  int actual_steps = 0;
  int result = 0;
  static char *capi_kwlist[] = {"t","p","q","steps","xi_current","potential","kforce","xi_range","save_trajectory","natoms","nbeads","potential_extra_args",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOOOOO|OOO!:_main.system.umbrella_trajectory",\
    capi_kwlist,&t_capi,&p_capi,&q_capi,&steps_capi,&xi_current_capi,&potential_capi,&kforce_capi,&xi_range_capi,&save_trajectory_capi,&natoms_capi,&nbeads_capi,&PyTuple_Type,&potential_xa_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable t */
    f2py_success = double_from_pyobj(&t,t_capi,"_main.system.umbrella_trajectory() 1st argument (t) can't be converted to double");
  if (f2py_success) {
  /* Processing variable p */
  p_Dims[0]=3;
  capi_p_intent |= F2PY_INTENT_INOUT;
  capi_p_tmp = array_from_pyobj(NPY_DOUBLE,p_Dims,p_Rank,capi_p_intent,p_capi);
  if (capi_p_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 2nd argument `p' of _main.system.umbrella_trajectory to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    p = (double *)(PyArray_DATA(capi_p_tmp));

  /* Processing variable steps */
    f2py_success = int_from_pyobj(&steps,steps_capi,"_main.system.umbrella_trajectory() 4th argument (steps) can't be converted to int");
  if (f2py_success) {
  /* Processing variable xi_current */
    f2py_success = double_from_pyobj(&xi_current,xi_current_capi,"_main.system.umbrella_trajectory() 5th argument (xi_current) can't be converted to double");
  if (f2py_success) {
  /* Processing variable potential */
if(F2PyCapsule_Check(potential_capi)) {
  potential_cptr = F2PyCapsule_AsVoidPtr(potential_capi);
} else {
  potential_cptr = cb_potential_in__main__user__routines;
}

  potential_nofargs_capi = cb_potential_in__main__user__routines_nofargs;
  if (create_cb_arglist(potential_capi,potential_xa_capi,3,2,&cb_potential_in__main__user__routines_nofargs,&potential_args_capi,"failed in processing argument list for call-back potential.")) {
    jmp_buf potential_jmpbuf;
    CFUNCSMESS("Saving jmpbuf for `potential`.\n");
    SWAP(potential_capi,cb_potential_in__main__user__routines_capi,PyObject);
    SWAP(potential_args_capi,cb_potential_in__main__user__routines_args_capi,PyTupleObject);
    memcpy(&potential_jmpbuf,&cb_potential_in__main__user__routines_jmpbuf,sizeof(jmp_buf));
  /* Processing variable kforce */
    f2py_success = double_from_pyobj(&kforce,kforce_capi,"_main.system.umbrella_trajectory() 7th argument (kforce) can't be converted to double");
  if (f2py_success) {
  /* Processing variable xi_range */
    f2py_success = double_from_pyobj(&xi_range,xi_range_capi,"_main.system.umbrella_trajectory() 8th argument (xi_range) can't be converted to double");
  if (f2py_success) {
  /* Processing variable save_trajectory */
    f2py_success = int_from_pyobj(&save_trajectory,save_trajectory_capi,"_main.system.umbrella_trajectory() 9th argument (save_trajectory) can't be converted to int");
  if (f2py_success) {
  /* Processing variable av */
  /* Processing variable av2 */
  /* Processing variable actual_steps */
  /* Processing variable result */
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(p,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.umbrella_trajectory() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,1)==natoms,"shape(p,1)==natoms","1st keyword natoms","umbrella_trajectory:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(p,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.umbrella_trajectory() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,2)==nbeads,"shape(p,2)==nbeads","2nd keyword nbeads","umbrella_trajectory:nbeads=%d",nbeads) {
  /* Processing variable q */
  q_Dims[0]=3,q_Dims[1]=natoms,q_Dims[2]=nbeads;
  capi_q_intent |= F2PY_INTENT_INOUT;
  capi_q_tmp = array_from_pyobj(NPY_DOUBLE,q_Dims,q_Rank,capi_q_intent,q_capi);
  if (capi_q_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 3rd argument `q' of _main.system.umbrella_trajectory to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    q = (double *)(PyArray_DATA(capi_q_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
    if ((setjmp(cb_potential_in__main__user__routines_jmpbuf))) {
      f2py_success = 0;
    } else {
        (*f2py_func)(&t,p,q,&natoms,&nbeads,&steps,&xi_current,potential_cptr,&kforce,&xi_range,&save_trajectory,&av,&av2,&actual_steps,&result);
    }
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
  f2py_success = try_pyarr_from_double(t_capi,&t);
  if (f2py_success) {
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("ddii",av,av2,actual_steps,result);
/*closepyobjfrom*/
  } /*if (f2py_success) of t pyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_q_tmp!=q_capi) {
    Py_XDECREF(capi_q_tmp); }
  }  /*if (capi_q_tmp == NULL) ... else of q*/
  /* End of cleaning variable q */
  } /*CHECKSCALAR(shape(p,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(p,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  /* End of cleaning variable result */
  /* End of cleaning variable actual_steps */
  /* End of cleaning variable av2 */
  /* End of cleaning variable av */
  } /*if (f2py_success) of save_trajectory*/
  /* End of cleaning variable save_trajectory */
  } /*if (f2py_success) of xi_range*/
  /* End of cleaning variable xi_range */
  } /*if (f2py_success) of kforce*/
  /* End of cleaning variable kforce */
    CFUNCSMESS("Restoring jmpbuf for `potential`.\n");
    cb_potential_in__main__user__routines_capi = potential_capi;
    Py_DECREF(cb_potential_in__main__user__routines_args_capi);
    cb_potential_in__main__user__routines_args_capi = potential_args_capi;
    cb_potential_in__main__user__routines_nofargs = potential_nofargs_capi;
    memcpy(&cb_potential_in__main__user__routines_jmpbuf,&potential_jmpbuf,sizeof(jmp_buf));
  }
  /* End of cleaning variable potential */
  } /*if (f2py_success) of xi_current*/
  /* End of cleaning variable xi_current */
  } /*if (f2py_success) of steps*/
  /* End of cleaning variable steps */
  if((PyObject *)capi_p_tmp!=p_capi) {
    Py_XDECREF(capi_p_tmp); }
  }  /*if (capi_p_tmp == NULL) ... else of p*/
  /* End of cleaning variable p */
  } /*if (f2py_success) of t*/
  /* End of cleaning variable t */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of umbrella_trajectory *************************/

/******************************** verlet_step ********************************/
static char doc_f2py_rout__main_system_verlet_step[] = "\
result = verlet_step(t,p,q,v,dvdq,xi,dxi,d2xi,xi_current,potential,kforce,constrain,[natoms,nbeads,potential_extra_args])\n\nWrapper for ``verlet_step``.\
\n\nParameters\n----------\n"
"t : in/output rank-0 array(float,'d')\n"
"p : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"q : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"v : in/output rank-1 array('d') with bounds (nbeads)\n"
"dvdq : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"xi : in/output rank-0 array(float,'d')\n"
"dxi : in/output rank-2 array('d') with bounds (3,natoms)\n"
"d2xi : in/output rank-4 array('d') with bounds (3,natoms,3,natoms)\n"
"xi_current : input float\n"
"potential : call-back function\n"
"kforce : input float\n"
"constrain : input int\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(p,1)\n"
"nbeads : input int, optional\n    Default: shape(p,2)\n"
"potential_extra_args : input tuple, optional\n    Default: ()\n"
"\nReturns\n-------\n"
"result : int\n"
"\nNotes\n-----\nCall-back functions::\n\n"
"  def potential(q,[natoms,nbeads]): return v,dvdq,info\n\
  Required arguments:\n"
"    q : input rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"  Optional arguments:\n"
"    natoms : input int, optional\n    Default: shape(q,1)\n"
"    nbeads : input int, optional\n    Default: shape(q,2)\n"
"  Return objects:\n"
"    v : rank-1 array('d') with bounds (nbeads)\n"
"    dvdq : rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"    info : int";
/*  */
static PyObject *f2py_rout__main_system_verlet_step(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,double*,double*,double*,double*,int*,int*,double*,cb_potential_in__main__user__routines_typedef,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double t = 0;
  PyObject *t_capi = Py_None;
  double *p = NULL;
  npy_intp p_Dims[3] = {-1, -1, -1};
  const int p_Rank = 3;
  PyArrayObject *capi_p_tmp = NULL;
  int capi_p_intent = 0;
  PyObject *p_capi = Py_None;
  double *q = NULL;
  npy_intp q_Dims[3] = {-1, -1, -1};
  const int q_Rank = 3;
  PyArrayObject *capi_q_tmp = NULL;
  int capi_q_intent = 0;
  PyObject *q_capi = Py_None;
  double *v = NULL;
  npy_intp v_Dims[1] = {-1};
  const int v_Rank = 1;
  PyArrayObject *capi_v_tmp = NULL;
  int capi_v_intent = 0;
  PyObject *v_capi = Py_None;
  double *dvdq = NULL;
  npy_intp dvdq_Dims[3] = {-1, -1, -1};
  const int dvdq_Rank = 3;
  PyArrayObject *capi_dvdq_tmp = NULL;
  int capi_dvdq_intent = 0;
  PyObject *dvdq_capi = Py_None;
  double xi = 0;
  PyObject *xi_capi = Py_None;
  double *dxi = NULL;
  npy_intp dxi_Dims[2] = {-1, -1};
  const int dxi_Rank = 2;
  PyArrayObject *capi_dxi_tmp = NULL;
  int capi_dxi_intent = 0;
  PyObject *dxi_capi = Py_None;
  double *d2xi = NULL;
  npy_intp d2xi_Dims[4] = {-1, -1, -1, -1};
  const int d2xi_Rank = 4;
  PyArrayObject *capi_d2xi_tmp = NULL;
  int capi_d2xi_intent = 0;
  PyObject *d2xi_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  double xi_current = 0;
  PyObject *xi_current_capi = Py_None;
  PyObject *potential_capi = Py_None;
  PyTupleObject *potential_xa_capi = NULL;
  PyTupleObject *potential_args_capi = NULL;
  int potential_nofargs_capi = 0;
  cb_potential_in__main__user__routines_typedef potential_cptr;
  double kforce = 0;
  PyObject *kforce_capi = Py_None;
  int constrain = 0;
  PyObject *constrain_capi = Py_None;
  int result = 0;
  static char *capi_kwlist[] = {"t","p","q","v","dvdq","xi","dxi","d2xi","xi_current","potential","kforce","constrain","natoms","nbeads","potential_extra_args",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOOOOOOOO|OOO!:_main.system.verlet_step",\
    capi_kwlist,&t_capi,&p_capi,&q_capi,&v_capi,&dvdq_capi,&xi_capi,&dxi_capi,&d2xi_capi,&xi_current_capi,&potential_capi,&kforce_capi,&constrain_capi,&natoms_capi,&nbeads_capi,&PyTuple_Type,&potential_xa_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable t */
    f2py_success = double_from_pyobj(&t,t_capi,"_main.system.verlet_step() 1st argument (t) can't be converted to double");
  if (f2py_success) {
  /* Processing variable p */
  p_Dims[0]=3;
  capi_p_intent |= F2PY_INTENT_INOUT;
  capi_p_tmp = array_from_pyobj(NPY_DOUBLE,p_Dims,p_Rank,capi_p_intent,p_capi);
  if (capi_p_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 2nd argument `p' of _main.system.verlet_step to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    p = (double *)(PyArray_DATA(capi_p_tmp));

  /* Processing variable xi */
    f2py_success = double_from_pyobj(&xi,xi_capi,"_main.system.verlet_step() 6th argument (xi) can't be converted to double");
  if (f2py_success) {
  /* Processing variable xi_current */
    f2py_success = double_from_pyobj(&xi_current,xi_current_capi,"_main.system.verlet_step() 9th argument (xi_current) can't be converted to double");
  if (f2py_success) {
  /* Processing variable potential */
if(F2PyCapsule_Check(potential_capi)) {
  potential_cptr = F2PyCapsule_AsVoidPtr(potential_capi);
} else {
  potential_cptr = cb_potential_in__main__user__routines;
}

  potential_nofargs_capi = cb_potential_in__main__user__routines_nofargs;
  if (create_cb_arglist(potential_capi,potential_xa_capi,3,2,&cb_potential_in__main__user__routines_nofargs,&potential_args_capi,"failed in processing argument list for call-back potential.")) {
    jmp_buf potential_jmpbuf;
    CFUNCSMESS("Saving jmpbuf for `potential`.\n");
    SWAP(potential_capi,cb_potential_in__main__user__routines_capi,PyObject);
    SWAP(potential_args_capi,cb_potential_in__main__user__routines_args_capi,PyTupleObject);
    memcpy(&potential_jmpbuf,&cb_potential_in__main__user__routines_jmpbuf,sizeof(jmp_buf));
  /* Processing variable kforce */
    f2py_success = double_from_pyobj(&kforce,kforce_capi,"_main.system.verlet_step() 11st argument (kforce) can't be converted to double");
  if (f2py_success) {
  /* Processing variable constrain */
    f2py_success = int_from_pyobj(&constrain,constrain_capi,"_main.system.verlet_step() 12nd argument (constrain) can't be converted to int");
  if (f2py_success) {
  /* Processing variable result */
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(p,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.verlet_step() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,1)==natoms,"shape(p,1)==natoms","1st keyword natoms","verlet_step:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(p,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.verlet_step() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,2)==nbeads,"shape(p,2)==nbeads","2nd keyword nbeads","verlet_step:nbeads=%d",nbeads) {
  /* Processing variable q */
  q_Dims[0]=3,q_Dims[1]=natoms,q_Dims[2]=nbeads;
  capi_q_intent |= F2PY_INTENT_INOUT;
  capi_q_tmp = array_from_pyobj(NPY_DOUBLE,q_Dims,q_Rank,capi_q_intent,q_capi);
  if (capi_q_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 3rd argument `q' of _main.system.verlet_step to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    q = (double *)(PyArray_DATA(capi_q_tmp));

  /* Processing variable v */
  v_Dims[0]=nbeads;
  capi_v_intent |= F2PY_INTENT_INOUT;
  capi_v_tmp = array_from_pyobj(NPY_DOUBLE,v_Dims,v_Rank,capi_v_intent,v_capi);
  if (capi_v_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 4th argument `v' of _main.system.verlet_step to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    v = (double *)(PyArray_DATA(capi_v_tmp));

  /* Processing variable dvdq */
  dvdq_Dims[0]=3,dvdq_Dims[1]=natoms,dvdq_Dims[2]=nbeads;
  capi_dvdq_intent |= F2PY_INTENT_INOUT;
  capi_dvdq_tmp = array_from_pyobj(NPY_DOUBLE,dvdq_Dims,dvdq_Rank,capi_dvdq_intent,dvdq_capi);
  if (capi_dvdq_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 5th argument `dvdq' of _main.system.verlet_step to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dvdq = (double *)(PyArray_DATA(capi_dvdq_tmp));

  /* Processing variable dxi */
  dxi_Dims[0]=3,dxi_Dims[1]=natoms;
  capi_dxi_intent |= F2PY_INTENT_INOUT;
  capi_dxi_tmp = array_from_pyobj(NPY_DOUBLE,dxi_Dims,dxi_Rank,capi_dxi_intent,dxi_capi);
  if (capi_dxi_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 7th argument `dxi' of _main.system.verlet_step to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dxi = (double *)(PyArray_DATA(capi_dxi_tmp));

  /* Processing variable d2xi */
  d2xi_Dims[0]=3,d2xi_Dims[1]=natoms,d2xi_Dims[2]=3,d2xi_Dims[3]=natoms;
  capi_d2xi_intent |= F2PY_INTENT_INOUT;
  capi_d2xi_tmp = array_from_pyobj(NPY_DOUBLE,d2xi_Dims,d2xi_Rank,capi_d2xi_intent,d2xi_capi);
  if (capi_d2xi_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 8th argument `d2xi' of _main.system.verlet_step to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    d2xi = (double *)(PyArray_DATA(capi_d2xi_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
    if ((setjmp(cb_potential_in__main__user__routines_jmpbuf))) {
      f2py_success = 0;
    } else {
        (*f2py_func)(&t,p,q,v,dvdq,&xi,dxi,d2xi,&natoms,&nbeads,&xi_current,potential_cptr,&kforce,&constrain,&result);
    }
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
  f2py_success = try_pyarr_from_double(t_capi,&t);
  if (f2py_success) {
  f2py_success = try_pyarr_from_double(xi_capi,&xi);
  if (f2py_success) {
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("i",result);
/*closepyobjfrom*/
  } /*if (f2py_success) of xi pyobjfrom*/
  } /*if (f2py_success) of t pyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_d2xi_tmp!=d2xi_capi) {
    Py_XDECREF(capi_d2xi_tmp); }
  }  /*if (capi_d2xi_tmp == NULL) ... else of d2xi*/
  /* End of cleaning variable d2xi */
  if((PyObject *)capi_dxi_tmp!=dxi_capi) {
    Py_XDECREF(capi_dxi_tmp); }
  }  /*if (capi_dxi_tmp == NULL) ... else of dxi*/
  /* End of cleaning variable dxi */
  if((PyObject *)capi_dvdq_tmp!=dvdq_capi) {
    Py_XDECREF(capi_dvdq_tmp); }
  }  /*if (capi_dvdq_tmp == NULL) ... else of dvdq*/
  /* End of cleaning variable dvdq */
  if((PyObject *)capi_v_tmp!=v_capi) {
    Py_XDECREF(capi_v_tmp); }
  }  /*if (capi_v_tmp == NULL) ... else of v*/
  /* End of cleaning variable v */
  if((PyObject *)capi_q_tmp!=q_capi) {
    Py_XDECREF(capi_q_tmp); }
  }  /*if (capi_q_tmp == NULL) ... else of q*/
  /* End of cleaning variable q */
  } /*CHECKSCALAR(shape(p,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(p,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  /* End of cleaning variable result */
  } /*if (f2py_success) of constrain*/
  /* End of cleaning variable constrain */
  } /*if (f2py_success) of kforce*/
  /* End of cleaning variable kforce */
    CFUNCSMESS("Restoring jmpbuf for `potential`.\n");
    cb_potential_in__main__user__routines_capi = potential_capi;
    Py_DECREF(cb_potential_in__main__user__routines_args_capi);
    cb_potential_in__main__user__routines_args_capi = potential_args_capi;
    cb_potential_in__main__user__routines_nofargs = potential_nofargs_capi;
    memcpy(&cb_potential_in__main__user__routines_jmpbuf,&potential_jmpbuf,sizeof(jmp_buf));
  }
  /* End of cleaning variable potential */
  } /*if (f2py_success) of xi_current*/
  /* End of cleaning variable xi_current */
  } /*if (f2py_success) of xi*/
  /* End of cleaning variable xi */
  if((PyObject *)capi_p_tmp!=p_capi) {
    Py_XDECREF(capi_p_tmp); }
  }  /*if (capi_p_tmp == NULL) ... else of p*/
  /* End of cleaning variable p */
  } /*if (f2py_success) of t*/
  /* End of cleaning variable t */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of verlet_step *****************************/

/*************************** free_ring_polymer_step ***************************/
static char doc_f2py_rout__main_system_free_ring_polymer_step[] = "\
free_ring_polymer_step(p,q,[natoms,nbeads])\n\nWrapper for ``free_ring_polymer_step``.\
\n\nParameters\n----------\n"
"p : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"q : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(p,1)\n"
"nbeads : input int, optional\n    Default: shape(p,2)";
/*  */
static PyObject *f2py_rout__main_system_free_ring_polymer_step(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *p = NULL;
  npy_intp p_Dims[3] = {-1, -1, -1};
  const int p_Rank = 3;
  PyArrayObject *capi_p_tmp = NULL;
  int capi_p_intent = 0;
  PyObject *p_capi = Py_None;
  double *q = NULL;
  npy_intp q_Dims[3] = {-1, -1, -1};
  const int q_Rank = 3;
  PyArrayObject *capi_q_tmp = NULL;
  int capi_q_intent = 0;
  PyObject *q_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  static char *capi_kwlist[] = {"p","q","natoms","nbeads",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO|OO:_main.system.free_ring_polymer_step",\
    capi_kwlist,&p_capi,&q_capi,&natoms_capi,&nbeads_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable p */
  p_Dims[0]=3;
  capi_p_intent |= F2PY_INTENT_INOUT;
  capi_p_tmp = array_from_pyobj(NPY_DOUBLE,p_Dims,p_Rank,capi_p_intent,p_capi);
  if (capi_p_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `p' of _main.system.free_ring_polymer_step to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    p = (double *)(PyArray_DATA(capi_p_tmp));

  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(p,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.free_ring_polymer_step() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,1)==natoms,"shape(p,1)==natoms","1st keyword natoms","free_ring_polymer_step:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(p,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.free_ring_polymer_step() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,2)==nbeads,"shape(p,2)==nbeads","2nd keyword nbeads","free_ring_polymer_step:nbeads=%d",nbeads) {
  /* Processing variable q */
  q_Dims[0]=3,q_Dims[1]=natoms,q_Dims[2]=nbeads;
  capi_q_intent |= F2PY_INTENT_INOUT;
  capi_q_tmp = array_from_pyobj(NPY_DOUBLE,q_Dims,q_Rank,capi_q_intent,q_capi);
  if (capi_q_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 2nd argument `q' of _main.system.free_ring_polymer_step to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    q = (double *)(PyArray_DATA(capi_q_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(p,q,&natoms,&nbeads);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_q_tmp!=q_capi) {
    Py_XDECREF(capi_q_tmp); }
  }  /*if (capi_q_tmp == NULL) ... else of q*/
  /* End of cleaning variable q */
  } /*CHECKSCALAR(shape(p,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(p,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  if((PyObject *)capi_p_tmp!=p_capi) {
    Py_XDECREF(capi_p_tmp); }
  }  /*if (capi_p_tmp == NULL) ... else of p*/
  /* End of cleaning variable p */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*********************** end of free_ring_polymer_step ***********************/

/*********************** constrain_to_dividing_surface ***********************/
static char doc_f2py_rout__main_system_constrain_to_dividing_surface[] = "\
info = constrain_to_dividing_surface(p,q,dxi,xi_current,[natoms,nbeads])\n\nWrapper for ``constrain_to_dividing_surface``.\
\n\nParameters\n----------\n"
"p : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"q : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"dxi : in/output rank-2 array('d') with bounds (3,natoms)\n"
"xi_current : input float\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(p,1)\n"
"nbeads : input int, optional\n    Default: shape(p,2)\n"
"\nReturns\n-------\n"
"info : int";
/*  */
static PyObject *f2py_rout__main_system_constrain_to_dividing_surface(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*,int*,double*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *p = NULL;
  npy_intp p_Dims[3] = {-1, -1, -1};
  const int p_Rank = 3;
  PyArrayObject *capi_p_tmp = NULL;
  int capi_p_intent = 0;
  PyObject *p_capi = Py_None;
  double *q = NULL;
  npy_intp q_Dims[3] = {-1, -1, -1};
  const int q_Rank = 3;
  PyArrayObject *capi_q_tmp = NULL;
  int capi_q_intent = 0;
  PyObject *q_capi = Py_None;
  double *dxi = NULL;
  npy_intp dxi_Dims[2] = {-1, -1};
  const int dxi_Rank = 2;
  PyArrayObject *capi_dxi_tmp = NULL;
  int capi_dxi_intent = 0;
  PyObject *dxi_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  double xi_current = 0;
  PyObject *xi_current_capi = Py_None;
  int info = 0;
  static char *capi_kwlist[] = {"p","q","dxi","xi_current","natoms","nbeads",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO|OO:_main.system.constrain_to_dividing_surface",\
    capi_kwlist,&p_capi,&q_capi,&dxi_capi,&xi_current_capi,&natoms_capi,&nbeads_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable p */
  p_Dims[0]=3;
  capi_p_intent |= F2PY_INTENT_INOUT;
  capi_p_tmp = array_from_pyobj(NPY_DOUBLE,p_Dims,p_Rank,capi_p_intent,p_capi);
  if (capi_p_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `p' of _main.system.constrain_to_dividing_surface to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    p = (double *)(PyArray_DATA(capi_p_tmp));

  /* Processing variable xi_current */
    f2py_success = double_from_pyobj(&xi_current,xi_current_capi,"_main.system.constrain_to_dividing_surface() 4th argument (xi_current) can't be converted to double");
  if (f2py_success) {
  /* Processing variable info */
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(p,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.constrain_to_dividing_surface() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,1)==natoms,"shape(p,1)==natoms","1st keyword natoms","constrain_to_dividing_surface:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(p,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.constrain_to_dividing_surface() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,2)==nbeads,"shape(p,2)==nbeads","2nd keyword nbeads","constrain_to_dividing_surface:nbeads=%d",nbeads) {
  /* Processing variable q */
  q_Dims[0]=3,q_Dims[1]=natoms,q_Dims[2]=nbeads;
  capi_q_intent |= F2PY_INTENT_INOUT;
  capi_q_tmp = array_from_pyobj(NPY_DOUBLE,q_Dims,q_Rank,capi_q_intent,q_capi);
  if (capi_q_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 2nd argument `q' of _main.system.constrain_to_dividing_surface to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    q = (double *)(PyArray_DATA(capi_q_tmp));

  /* Processing variable dxi */
  dxi_Dims[0]=3,dxi_Dims[1]=natoms;
  capi_dxi_intent |= F2PY_INTENT_INOUT;
  capi_dxi_tmp = array_from_pyobj(NPY_DOUBLE,dxi_Dims,dxi_Rank,capi_dxi_intent,dxi_capi);
  if (capi_dxi_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 3rd argument `dxi' of _main.system.constrain_to_dividing_surface to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dxi = (double *)(PyArray_DATA(capi_dxi_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(p,q,dxi,&natoms,&nbeads,&xi_current,&info);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("i",info);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_dxi_tmp!=dxi_capi) {
    Py_XDECREF(capi_dxi_tmp); }
  }  /*if (capi_dxi_tmp == NULL) ... else of dxi*/
  /* End of cleaning variable dxi */
  if((PyObject *)capi_q_tmp!=q_capi) {
    Py_XDECREF(capi_q_tmp); }
  }  /*if (capi_q_tmp == NULL) ... else of q*/
  /* End of cleaning variable q */
  } /*CHECKSCALAR(shape(p,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(p,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  /* End of cleaning variable info */
  } /*if (f2py_success) of xi_current*/
  /* End of cleaning variable xi_current */
  if((PyObject *)capi_p_tmp!=p_capi) {
    Py_XDECREF(capi_p_tmp); }
  }  /*if (capi_p_tmp == NULL) ... else of p*/
  /* End of cleaning variable p */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************** end of constrain_to_dividing_surface ********************/

/******************* constrain_momentum_to_dividing_surface *******************/
static char doc_f2py_rout__main_system_constrain_momentum_to_dividing_surface[] = "\
constrain_momentum_to_dividing_surface(p,dxi,[natoms,nbeads])\n\nWrapper for ``constrain_momentum_to_dividing_surface``.\
\n\nParameters\n----------\n"
"p : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"dxi : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(p,1)\n"
"nbeads : input int, optional\n    Default: shape(p,2)";
/*  */
static PyObject *f2py_rout__main_system_constrain_momentum_to_dividing_surface(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *p = NULL;
  npy_intp p_Dims[3] = {-1, -1, -1};
  const int p_Rank = 3;
  PyArrayObject *capi_p_tmp = NULL;
  int capi_p_intent = 0;
  PyObject *p_capi = Py_None;
  double *dxi = NULL;
  npy_intp dxi_Dims[2] = {-1, -1};
  const int dxi_Rank = 2;
  PyArrayObject *capi_dxi_tmp = NULL;
  int capi_dxi_intent = 0;
  PyObject *dxi_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  static char *capi_kwlist[] = {"p","dxi","natoms","nbeads",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO|OO:_main.system.constrain_momentum_to_dividing_surface",\
    capi_kwlist,&p_capi,&dxi_capi,&natoms_capi,&nbeads_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable p */
  p_Dims[0]=3;
  capi_p_intent |= F2PY_INTENT_INOUT;
  capi_p_tmp = array_from_pyobj(NPY_DOUBLE,p_Dims,p_Rank,capi_p_intent,p_capi);
  if (capi_p_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `p' of _main.system.constrain_momentum_to_dividing_surface to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    p = (double *)(PyArray_DATA(capi_p_tmp));

  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(p,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.constrain_momentum_to_dividing_surface() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,1)==natoms,"shape(p,1)==natoms","1st keyword natoms","constrain_momentum_to_dividing_surface:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(p,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.constrain_momentum_to_dividing_surface() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,2)==nbeads,"shape(p,2)==nbeads","2nd keyword nbeads","constrain_momentum_to_dividing_surface:nbeads=%d",nbeads) {
  /* Processing variable dxi */
  dxi_Dims[0]=3,dxi_Dims[1]=natoms;
  capi_dxi_intent |= F2PY_INTENT_IN;
  capi_dxi_tmp = array_from_pyobj(NPY_DOUBLE,dxi_Dims,dxi_Rank,capi_dxi_intent,dxi_capi);
  if (capi_dxi_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 2nd argument `dxi' of _main.system.constrain_momentum_to_dividing_surface to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dxi = (double *)(PyArray_DATA(capi_dxi_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(p,dxi,&natoms,&nbeads);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_dxi_tmp!=dxi_capi) {
    Py_XDECREF(capi_dxi_tmp); }
  }  /*if (capi_dxi_tmp == NULL) ... else of dxi*/
  /* End of cleaning variable dxi */
  } /*CHECKSCALAR(shape(p,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(p,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  if((PyObject *)capi_p_tmp!=p_capi) {
    Py_XDECREF(capi_p_tmp); }
  }  /*if (capi_p_tmp == NULL) ... else of p*/
  /* End of cleaning variable p */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************** end of constrain_momentum_to_dividing_surface ***************/

/*************************** add_umbrella_potential ***************************/
static char doc_f2py_rout__main_system_add_umbrella_potential[] = "\
add_umbrella_potential(xi,dxi,v,dvdq,xi_current,kforce,[natoms,nbeads])\n\nWrapper for ``add_umbrella_potential``.\
\n\nParameters\n----------\n"
"xi : input float\n"
"dxi : input rank-2 array('d') with bounds (3,natoms)\n"
"v : in/output rank-1 array('d') with bounds (nbeads)\n"
"dvdq : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"xi_current : input float\n"
"kforce : input float\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(dxi,1)\n"
"nbeads : input int, optional\n    Default: len(v)";
/*  */
static PyObject *f2py_rout__main_system_add_umbrella_potential(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,int*,int*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double xi = 0;
  PyObject *xi_capi = Py_None;
  double *dxi = NULL;
  npy_intp dxi_Dims[2] = {-1, -1};
  const int dxi_Rank = 2;
  PyArrayObject *capi_dxi_tmp = NULL;
  int capi_dxi_intent = 0;
  PyObject *dxi_capi = Py_None;
  double *v = NULL;
  npy_intp v_Dims[1] = {-1};
  const int v_Rank = 1;
  PyArrayObject *capi_v_tmp = NULL;
  int capi_v_intent = 0;
  PyObject *v_capi = Py_None;
  double *dvdq = NULL;
  npy_intp dvdq_Dims[3] = {-1, -1, -1};
  const int dvdq_Rank = 3;
  PyArrayObject *capi_dvdq_tmp = NULL;
  int capi_dvdq_intent = 0;
  PyObject *dvdq_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  double xi_current = 0;
  PyObject *xi_current_capi = Py_None;
  double kforce = 0;
  PyObject *kforce_capi = Py_None;
  static char *capi_kwlist[] = {"xi","dxi","v","dvdq","xi_current","kforce","natoms","nbeads",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOO|OO:_main.system.add_umbrella_potential",\
    capi_kwlist,&xi_capi,&dxi_capi,&v_capi,&dvdq_capi,&xi_current_capi,&kforce_capi,&natoms_capi,&nbeads_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable xi */
    f2py_success = double_from_pyobj(&xi,xi_capi,"_main.system.add_umbrella_potential() 1st argument (xi) can't be converted to double");
  if (f2py_success) {
  /* Processing variable dxi */
  dxi_Dims[0]=3;
  capi_dxi_intent |= F2PY_INTENT_IN;
  capi_dxi_tmp = array_from_pyobj(NPY_DOUBLE,dxi_Dims,dxi_Rank,capi_dxi_intent,dxi_capi);
  if (capi_dxi_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 2nd argument `dxi' of _main.system.add_umbrella_potential to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dxi = (double *)(PyArray_DATA(capi_dxi_tmp));

  /* Processing variable v */
  ;
  capi_v_intent |= F2PY_INTENT_INOUT;
  capi_v_tmp = array_from_pyobj(NPY_DOUBLE,v_Dims,v_Rank,capi_v_intent,v_capi);
  if (capi_v_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 3rd argument `v' of _main.system.add_umbrella_potential to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    v = (double *)(PyArray_DATA(capi_v_tmp));

  /* Processing variable xi_current */
    f2py_success = double_from_pyobj(&xi_current,xi_current_capi,"_main.system.add_umbrella_potential() 5th argument (xi_current) can't be converted to double");
  if (f2py_success) {
  /* Processing variable kforce */
    f2py_success = double_from_pyobj(&kforce,kforce_capi,"_main.system.add_umbrella_potential() 6th argument (kforce) can't be converted to double");
  if (f2py_success) {
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(dxi,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.add_umbrella_potential() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(dxi,1)==natoms,"shape(dxi,1)==natoms","1st keyword natoms","add_umbrella_potential:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = len(v); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.add_umbrella_potential() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(v)>=nbeads,"len(v)>=nbeads","2nd keyword nbeads","add_umbrella_potential:nbeads=%d",nbeads) {
  /* Processing variable dvdq */
  dvdq_Dims[0]=3,dvdq_Dims[1]=natoms,dvdq_Dims[2]=nbeads;
  capi_dvdq_intent |= F2PY_INTENT_INOUT;
  capi_dvdq_tmp = array_from_pyobj(NPY_DOUBLE,dvdq_Dims,dvdq_Rank,capi_dvdq_intent,dvdq_capi);
  if (capi_dvdq_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 4th argument `dvdq' of _main.system.add_umbrella_potential to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dvdq = (double *)(PyArray_DATA(capi_dvdq_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&xi,dxi,v,dvdq,&natoms,&nbeads,&xi_current,&kforce);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_dvdq_tmp!=dvdq_capi) {
    Py_XDECREF(capi_dvdq_tmp); }
  }  /*if (capi_dvdq_tmp == NULL) ... else of dvdq*/
  /* End of cleaning variable dvdq */
  } /*CHECKSCALAR(len(v)>=nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(dxi,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  } /*if (f2py_success) of kforce*/
  /* End of cleaning variable kforce */
  } /*if (f2py_success) of xi_current*/
  /* End of cleaning variable xi_current */
  if((PyObject *)capi_v_tmp!=v_capi) {
    Py_XDECREF(capi_v_tmp); }
  }  /*if (capi_v_tmp == NULL) ... else of v*/
  /* End of cleaning variable v */
  if((PyObject *)capi_dxi_tmp!=dxi_capi) {
    Py_XDECREF(capi_dxi_tmp); }
  }  /*if (capi_dxi_tmp == NULL) ... else of dxi*/
  /* End of cleaning variable dxi */
  } /*if (f2py_success) of xi*/
  /* End of cleaning variable xi */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*********************** end of add_umbrella_potential ***********************/

/***************************** add_bias_potential *****************************/
static char doc_f2py_rout__main_system_add_bias_potential[] = "\
add_bias_potential(dxi,d2xi,v,dvdq,[natoms,nbeads])\n\nWrapper for ``add_bias_potential``.\
\n\nParameters\n----------\n"
"dxi : input rank-2 array('d') with bounds (3,natoms)\n"
"d2xi : input rank-4 array('d') with bounds (3,natoms,3,natoms)\n"
"v : in/output rank-1 array('d') with bounds (nbeads)\n"
"dvdq : in/output rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(dxi,1)\n"
"nbeads : input int, optional\n    Default: len(v)";
/*  */
static PyObject *f2py_rout__main_system_add_bias_potential(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *dxi = NULL;
  npy_intp dxi_Dims[2] = {-1, -1};
  const int dxi_Rank = 2;
  PyArrayObject *capi_dxi_tmp = NULL;
  int capi_dxi_intent = 0;
  PyObject *dxi_capi = Py_None;
  double *d2xi = NULL;
  npy_intp d2xi_Dims[4] = {-1, -1, -1, -1};
  const int d2xi_Rank = 4;
  PyArrayObject *capi_d2xi_tmp = NULL;
  int capi_d2xi_intent = 0;
  PyObject *d2xi_capi = Py_None;
  double *v = NULL;
  npy_intp v_Dims[1] = {-1};
  const int v_Rank = 1;
  PyArrayObject *capi_v_tmp = NULL;
  int capi_v_intent = 0;
  PyObject *v_capi = Py_None;
  double *dvdq = NULL;
  npy_intp dvdq_Dims[3] = {-1, -1, -1};
  const int dvdq_Rank = 3;
  PyArrayObject *capi_dvdq_tmp = NULL;
  int capi_dvdq_intent = 0;
  PyObject *dvdq_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  static char *capi_kwlist[] = {"dxi","d2xi","v","dvdq","natoms","nbeads",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO|OO:_main.system.add_bias_potential",\
    capi_kwlist,&dxi_capi,&d2xi_capi,&v_capi,&dvdq_capi,&natoms_capi,&nbeads_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable dxi */
  dxi_Dims[0]=3;
  capi_dxi_intent |= F2PY_INTENT_IN;
  capi_dxi_tmp = array_from_pyobj(NPY_DOUBLE,dxi_Dims,dxi_Rank,capi_dxi_intent,dxi_capi);
  if (capi_dxi_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `dxi' of _main.system.add_bias_potential to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dxi = (double *)(PyArray_DATA(capi_dxi_tmp));

  /* Processing variable v */
  ;
  capi_v_intent |= F2PY_INTENT_INOUT;
  capi_v_tmp = array_from_pyobj(NPY_DOUBLE,v_Dims,v_Rank,capi_v_intent,v_capi);
  if (capi_v_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 3rd argument `v' of _main.system.add_bias_potential to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    v = (double *)(PyArray_DATA(capi_v_tmp));

  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(dxi,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.add_bias_potential() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(dxi,1)==natoms,"shape(dxi,1)==natoms","1st keyword natoms","add_bias_potential:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = len(v); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.add_bias_potential() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(v)>=nbeads,"len(v)>=nbeads","2nd keyword nbeads","add_bias_potential:nbeads=%d",nbeads) {
  /* Processing variable d2xi */
  d2xi_Dims[0]=3,d2xi_Dims[1]=natoms,d2xi_Dims[2]=3,d2xi_Dims[3]=natoms;
  capi_d2xi_intent |= F2PY_INTENT_IN;
  capi_d2xi_tmp = array_from_pyobj(NPY_DOUBLE,d2xi_Dims,d2xi_Rank,capi_d2xi_intent,d2xi_capi);
  if (capi_d2xi_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 2nd argument `d2xi' of _main.system.add_bias_potential to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    d2xi = (double *)(PyArray_DATA(capi_d2xi_tmp));

  /* Processing variable dvdq */
  dvdq_Dims[0]=3,dvdq_Dims[1]=natoms,dvdq_Dims[2]=nbeads;
  capi_dvdq_intent |= F2PY_INTENT_INOUT;
  capi_dvdq_tmp = array_from_pyobj(NPY_DOUBLE,dvdq_Dims,dvdq_Rank,capi_dvdq_intent,dvdq_capi);
  if (capi_dvdq_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 4th argument `dvdq' of _main.system.add_bias_potential to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dvdq = (double *)(PyArray_DATA(capi_dvdq_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(dxi,d2xi,v,dvdq,&natoms,&nbeads);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_dvdq_tmp!=dvdq_capi) {
    Py_XDECREF(capi_dvdq_tmp); }
  }  /*if (capi_dvdq_tmp == NULL) ... else of dvdq*/
  /* End of cleaning variable dvdq */
  if((PyObject *)capi_d2xi_tmp!=d2xi_capi) {
    Py_XDECREF(capi_d2xi_tmp); }
  }  /*if (capi_d2xi_tmp == NULL) ... else of d2xi*/
  /* End of cleaning variable d2xi */
  } /*CHECKSCALAR(len(v)>=nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(dxi,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  if((PyObject *)capi_v_tmp!=v_capi) {
    Py_XDECREF(capi_v_tmp); }
  }  /*if (capi_v_tmp == NULL) ... else of v*/
  /* End of cleaning variable v */
  if((PyObject *)capi_dxi_tmp!=dxi_capi) {
    Py_XDECREF(capi_dxi_tmp); }
  }  /*if (capi_dxi_tmp == NULL) ... else of dxi*/
  /* End of cleaning variable dxi */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of add_bias_potential *************************/

/************************** get_reaction_coordinate **************************/
static char doc_f2py_rout__main_system_get_reaction_coordinate[] = "\
xi,dxi,d2xi = get_reaction_coordinate(centroid,xi_current,[natoms])\n\nWrapper for ``get_reaction_coordinate``.\
\n\nParameters\n----------\n"
"centroid : input rank-2 array('d') with bounds (3,natoms)\n"
"xi_current : input float\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(centroid,1)\n"
"\nReturns\n-------\n"
"xi : float\n"
"dxi : rank-2 array('d') with bounds (3,natoms)\n"
"d2xi : rank-4 array('d') with bounds (3,natoms,3,natoms)";
/*  */
static PyObject *f2py_rout__main_system_get_reaction_coordinate(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *centroid = NULL;
  npy_intp centroid_Dims[2] = {-1, -1};
  const int centroid_Rank = 2;
  PyArrayObject *capi_centroid_tmp = NULL;
  int capi_centroid_intent = 0;
  PyObject *centroid_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  double xi_current = 0;
  PyObject *xi_current_capi = Py_None;
  double xi = 0;
  double *dxi = NULL;
  npy_intp dxi_Dims[2] = {-1, -1};
  const int dxi_Rank = 2;
  PyArrayObject *capi_dxi_tmp = NULL;
  int capi_dxi_intent = 0;
  double *d2xi = NULL;
  npy_intp d2xi_Dims[4] = {-1, -1, -1, -1};
  const int d2xi_Rank = 4;
  PyArrayObject *capi_d2xi_tmp = NULL;
  int capi_d2xi_intent = 0;
  static char *capi_kwlist[] = {"centroid","xi_current","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO|O:_main.system.get_reaction_coordinate",\
    capi_kwlist,&centroid_capi,&xi_current_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable centroid */
  centroid_Dims[0]=3;
  capi_centroid_intent |= F2PY_INTENT_IN;
  capi_centroid_tmp = array_from_pyobj(NPY_DOUBLE,centroid_Dims,centroid_Rank,capi_centroid_intent,centroid_capi);
  if (capi_centroid_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `centroid' of _main.system.get_reaction_coordinate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    centroid = (double *)(PyArray_DATA(capi_centroid_tmp));

  /* Processing variable xi_current */
    f2py_success = double_from_pyobj(&xi_current,xi_current_capi,"_main.system.get_reaction_coordinate() 2nd argument (xi_current) can't be converted to double");
  if (f2py_success) {
  /* Processing variable xi */
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(centroid,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.get_reaction_coordinate() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(centroid,1)==natoms,"shape(centroid,1)==natoms","1st keyword natoms","get_reaction_coordinate:natoms=%d",natoms) {
  /* Processing variable dxi */
  dxi_Dims[0]=3,dxi_Dims[1]=natoms;
  capi_dxi_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_dxi_tmp = array_from_pyobj(NPY_DOUBLE,dxi_Dims,dxi_Rank,capi_dxi_intent,Py_None);
  if (capi_dxi_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `dxi' of _main.system.get_reaction_coordinate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dxi = (double *)(PyArray_DATA(capi_dxi_tmp));

  /* Processing variable d2xi */
  d2xi_Dims[0]=3,d2xi_Dims[1]=natoms,d2xi_Dims[2]=3,d2xi_Dims[3]=natoms;
  capi_d2xi_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_d2xi_tmp = array_from_pyobj(NPY_DOUBLE,d2xi_Dims,d2xi_Rank,capi_d2xi_intent,Py_None);
  if (capi_d2xi_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `d2xi' of _main.system.get_reaction_coordinate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    d2xi = (double *)(PyArray_DATA(capi_d2xi_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(centroid,&natoms,&xi_current,&xi,dxi,d2xi);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("dNN",xi,capi_dxi_tmp,capi_d2xi_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_d2xi_tmp == NULL) ... else of d2xi*/
  /* End of cleaning variable d2xi */
  }  /*if (capi_dxi_tmp == NULL) ... else of dxi*/
  /* End of cleaning variable dxi */
  } /*CHECKSCALAR(shape(centroid,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  /* End of cleaning variable xi */
  } /*if (f2py_success) of xi_current*/
  /* End of cleaning variable xi_current */
  if((PyObject *)capi_centroid_tmp!=centroid_capi) {
    Py_XDECREF(capi_centroid_tmp); }
  }  /*if (capi_centroid_tmp == NULL) ... else of centroid*/
  /* End of cleaning variable centroid */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*********************** end of get_reaction_coordinate ***********************/

/**************************** get_recrossing_flux ****************************/
static char doc_f2py_rout__main_system_get_recrossing_flux[] = "\
fs = get_recrossing_flux(dxi,[natoms])\n\nWrapper for ``get_recrossing_flux``.\
\n\nParameters\n----------\n"
"dxi : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(dxi,1)\n"
"\nReturns\n-------\n"
"fs : float";
/*  */
static PyObject *f2py_rout__main_system_get_recrossing_flux(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *dxi = NULL;
  npy_intp dxi_Dims[2] = {-1, -1};
  const int dxi_Rank = 2;
  PyArrayObject *capi_dxi_tmp = NULL;
  int capi_dxi_intent = 0;
  PyObject *dxi_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  double fs = 0;
  static char *capi_kwlist[] = {"dxi","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.system.get_recrossing_flux",\
    capi_kwlist,&dxi_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable dxi */
  dxi_Dims[0]=3;
  capi_dxi_intent |= F2PY_INTENT_IN;
  capi_dxi_tmp = array_from_pyobj(NPY_DOUBLE,dxi_Dims,dxi_Rank,capi_dxi_intent,dxi_capi);
  if (capi_dxi_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `dxi' of _main.system.get_recrossing_flux to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dxi = (double *)(PyArray_DATA(capi_dxi_tmp));

  /* Processing variable fs */
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(dxi,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.get_recrossing_flux() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(dxi,1)==natoms,"shape(dxi,1)==natoms","1st keyword natoms","get_recrossing_flux:natoms=%d",natoms) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(dxi,&natoms,&fs);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",fs);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(dxi,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  /* End of cleaning variable fs */
  if((PyObject *)capi_dxi_tmp!=dxi_capi) {
    Py_XDECREF(capi_dxi_tmp); }
  }  /*if (capi_dxi_tmp == NULL) ... else of dxi*/
  /* End of cleaning variable dxi */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of get_recrossing_flux *************************/

/************************** get_recrossing_velocity **************************/
static char doc_f2py_rout__main_system_get_recrossing_velocity[] = "\
vs = get_recrossing_velocity(p,dxi,[natoms,nbeads])\n\nWrapper for ``get_recrossing_velocity``.\
\n\nParameters\n----------\n"
"p : input rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"dxi : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(p,1)\n"
"nbeads : input int, optional\n    Default: shape(p,2)\n"
"\nReturns\n-------\n"
"vs : float";
/*  */
static PyObject *f2py_rout__main_system_get_recrossing_velocity(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,int*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *p = NULL;
  npy_intp p_Dims[3] = {-1, -1, -1};
  const int p_Rank = 3;
  PyArrayObject *capi_p_tmp = NULL;
  int capi_p_intent = 0;
  PyObject *p_capi = Py_None;
  double *dxi = NULL;
  npy_intp dxi_Dims[2] = {-1, -1};
  const int dxi_Rank = 2;
  PyArrayObject *capi_dxi_tmp = NULL;
  int capi_dxi_intent = 0;
  PyObject *dxi_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  double vs = 0;
  static char *capi_kwlist[] = {"p","dxi","natoms","nbeads",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO|OO:_main.system.get_recrossing_velocity",\
    capi_kwlist,&p_capi,&dxi_capi,&natoms_capi,&nbeads_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable p */
  p_Dims[0]=3;
  capi_p_intent |= F2PY_INTENT_IN;
  capi_p_tmp = array_from_pyobj(NPY_DOUBLE,p_Dims,p_Rank,capi_p_intent,p_capi);
  if (capi_p_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `p' of _main.system.get_recrossing_velocity to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    p = (double *)(PyArray_DATA(capi_p_tmp));

  /* Processing variable vs */
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(p,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.get_recrossing_velocity() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,1)==natoms,"shape(p,1)==natoms","1st keyword natoms","get_recrossing_velocity:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(p,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.get_recrossing_velocity() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,2)==nbeads,"shape(p,2)==nbeads","2nd keyword nbeads","get_recrossing_velocity:nbeads=%d",nbeads) {
  /* Processing variable dxi */
  dxi_Dims[0]=3,dxi_Dims[1]=natoms;
  capi_dxi_intent |= F2PY_INTENT_IN;
  capi_dxi_tmp = array_from_pyobj(NPY_DOUBLE,dxi_Dims,dxi_Rank,capi_dxi_intent,dxi_capi);
  if (capi_dxi_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 2nd argument `dxi' of _main.system.get_recrossing_velocity to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    dxi = (double *)(PyArray_DATA(capi_dxi_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(p,dxi,&natoms,&nbeads,&vs);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",vs);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  if((PyObject *)capi_dxi_tmp!=dxi_capi) {
    Py_XDECREF(capi_dxi_tmp); }
  }  /*if (capi_dxi_tmp == NULL) ... else of dxi*/
  /* End of cleaning variable dxi */
  } /*CHECKSCALAR(shape(p,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(p,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  /* End of cleaning variable vs */
  if((PyObject *)capi_p_tmp!=p_capi) {
    Py_XDECREF(capi_p_tmp); }
  }  /*if (capi_p_tmp == NULL) ... else of p*/
  /* End of cleaning variable p */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*********************** end of get_recrossing_velocity ***********************/

/****************************** sample_momentum ******************************/
static char doc_f2py_rout__main_system_sample_momentum[] = "\
p = sample_momentum(mass,beta,nbeads,[natoms])\n\nWrapper for ``sample_momentum``.\
\n\nParameters\n----------\n"
"mass : input rank-1 array('d') with bounds (natoms)\n"
"beta : input float\n"
"nbeads : input int\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: len(mass)\n"
"\nReturns\n-------\n"
"p : rank-3 array('d') with bounds (3,natoms,nbeads)";
/*  */
static PyObject *f2py_rout__main_system_sample_momentum(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *p = NULL;
  npy_intp p_Dims[3] = {-1, -1, -1};
  const int p_Rank = 3;
  PyArrayObject *capi_p_tmp = NULL;
  int capi_p_intent = 0;
  double *mass = NULL;
  npy_intp mass_Dims[1] = {-1};
  const int mass_Rank = 1;
  PyArrayObject *capi_mass_tmp = NULL;
  int capi_mass_intent = 0;
  PyObject *mass_capi = Py_None;
  double beta = 0;
  PyObject *beta_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  static char *capi_kwlist[] = {"mass","beta","nbeads","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO|O:_main.system.sample_momentum",\
    capi_kwlist,&mass_capi,&beta_capi,&nbeads_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mass */
  ;
  capi_mass_intent |= F2PY_INTENT_IN;
  capi_mass_tmp = array_from_pyobj(NPY_DOUBLE,mass_Dims,mass_Rank,capi_mass_intent,mass_capi);
  if (capi_mass_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `mass' of _main.system.sample_momentum to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    mass = (double *)(PyArray_DATA(capi_mass_tmp));

  /* Processing variable beta */
    f2py_success = double_from_pyobj(&beta,beta_capi,"_main.system.sample_momentum() 2nd argument (beta) can't be converted to double");
  if (f2py_success) {
  /* Processing variable nbeads */
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.sample_momentum() 3rd argument (nbeads) can't be converted to int");
  if (f2py_success) {
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = len(mass); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.sample_momentum() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(len(mass)>=natoms,"len(mass)>=natoms","1st keyword natoms","sample_momentum:natoms=%d",natoms) {
  /* Processing variable p */
  p_Dims[0]=3,p_Dims[1]=natoms,p_Dims[2]=nbeads;
  capi_p_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_p_tmp = array_from_pyobj(NPY_DOUBLE,p_Dims,p_Rank,capi_p_intent,Py_None);
  if (capi_p_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `p' of _main.system.sample_momentum to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    p = (double *)(PyArray_DATA(capi_p_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(p,mass,&beta,&natoms,&nbeads);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_p_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_p_tmp == NULL) ... else of p*/
  /* End of cleaning variable p */
  } /*CHECKSCALAR(len(mass)>=natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*if (f2py_success) of beta*/
  /* End of cleaning variable beta */
  if((PyObject *)capi_mass_tmp!=mass_capi) {
    Py_XDECREF(capi_mass_tmp); }
  }  /*if (capi_mass_tmp == NULL) ... else of mass*/
  /* End of cleaning variable mass */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*************************** end of sample_momentum ***************************/

/************************** get_ring_polymer_energy **************************/
static char doc_f2py_rout__main_system_get_ring_polymer_energy[] = "\
ering = get_ring_polymer_energy(q,[natoms,nbeads])\n\nWrapper for ``get_ring_polymer_energy``.\
\n\nParameters\n----------\n"
"q : input rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(q,1)\n"
"nbeads : input int, optional\n    Default: shape(q,2)\n"
"\nReturns\n-------\n"
"ering : float";
/*  */
static PyObject *f2py_rout__main_system_get_ring_polymer_energy(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *q = NULL;
  npy_intp q_Dims[3] = {-1, -1, -1};
  const int q_Rank = 3;
  PyArrayObject *capi_q_tmp = NULL;
  int capi_q_intent = 0;
  PyObject *q_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  double ering = 0;
  static char *capi_kwlist[] = {"q","natoms","nbeads",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OO:_main.system.get_ring_polymer_energy",\
    capi_kwlist,&q_capi,&natoms_capi,&nbeads_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable q */
  q_Dims[0]=3;
  capi_q_intent |= F2PY_INTENT_IN;
  capi_q_tmp = array_from_pyobj(NPY_DOUBLE,q_Dims,q_Rank,capi_q_intent,q_capi);
  if (capi_q_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `q' of _main.system.get_ring_polymer_energy to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    q = (double *)(PyArray_DATA(capi_q_tmp));

  /* Processing variable ering */
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(q,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.get_ring_polymer_energy() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(q,1)==natoms,"shape(q,1)==natoms","1st keyword natoms","get_ring_polymer_energy:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(q,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.get_ring_polymer_energy() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(q,2)==nbeads,"shape(q,2)==nbeads","2nd keyword nbeads","get_ring_polymer_energy:nbeads=%d",nbeads) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(q,&natoms,&nbeads,&ering);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",ering);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(q,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(q,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  /* End of cleaning variable ering */
  if((PyObject *)capi_q_tmp!=q_capi) {
    Py_XDECREF(capi_q_tmp); }
  }  /*if (capi_q_tmp == NULL) ... else of q*/
  /* End of cleaning variable q */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*********************** end of get_ring_polymer_energy ***********************/

/***************************** get_kinetic_energy *****************************/
static char doc_f2py_rout__main_system_get_kinetic_energy[] = "\
ek = get_kinetic_energy(p,[natoms,nbeads])\n\nWrapper for ``get_kinetic_energy``.\
\n\nParameters\n----------\n"
"p : input rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(p,1)\n"
"nbeads : input int, optional\n    Default: shape(p,2)\n"
"\nReturns\n-------\n"
"ek : float";
/*  */
static PyObject *f2py_rout__main_system_get_kinetic_energy(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *p = NULL;
  npy_intp p_Dims[3] = {-1, -1, -1};
  const int p_Rank = 3;
  PyArrayObject *capi_p_tmp = NULL;
  int capi_p_intent = 0;
  PyObject *p_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  double ek = 0;
  static char *capi_kwlist[] = {"p","natoms","nbeads",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OO:_main.system.get_kinetic_energy",\
    capi_kwlist,&p_capi,&natoms_capi,&nbeads_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable p */
  p_Dims[0]=3;
  capi_p_intent |= F2PY_INTENT_IN;
  capi_p_tmp = array_from_pyobj(NPY_DOUBLE,p_Dims,p_Rank,capi_p_intent,p_capi);
  if (capi_p_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `p' of _main.system.get_kinetic_energy to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    p = (double *)(PyArray_DATA(capi_p_tmp));

  /* Processing variable ek */
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(p,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.get_kinetic_energy() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,1)==natoms,"shape(p,1)==natoms","1st keyword natoms","get_kinetic_energy:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(p,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.get_kinetic_energy() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(p,2)==nbeads,"shape(p,2)==nbeads","2nd keyword nbeads","get_kinetic_energy:nbeads=%d",nbeads) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(p,&natoms,&nbeads,&ek);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",ek);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(p,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(p,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  /* End of cleaning variable ek */
  if((PyObject *)capi_p_tmp!=p_capi) {
    Py_XDECREF(capi_p_tmp); }
  }  /*if (capi_p_tmp == NULL) ... else of p*/
  /* End of cleaning variable p */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of get_kinetic_energy *************************/

/***************************** get_center_of_mass *****************************/
static char doc_f2py_rout__main_system_get_center_of_mass[] = "\
cm = get_center_of_mass(q,[natoms,nbeads])\n\nWrapper for ``get_center_of_mass``.\
\n\nParameters\n----------\n"
"q : input rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(q,1)\n"
"nbeads : input int, optional\n    Default: shape(q,2)\n"
"\nReturns\n-------\n"
"cm : rank-1 array('d') with bounds (3)";
/*  */
static PyObject *f2py_rout__main_system_get_center_of_mass(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *q = NULL;
  npy_intp q_Dims[3] = {-1, -1, -1};
  const int q_Rank = 3;
  PyArrayObject *capi_q_tmp = NULL;
  int capi_q_intent = 0;
  PyObject *q_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  double *cm = NULL;
  npy_intp cm_Dims[1] = {-1};
  const int cm_Rank = 1;
  PyArrayObject *capi_cm_tmp = NULL;
  int capi_cm_intent = 0;
  static char *capi_kwlist[] = {"q","natoms","nbeads",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OO:_main.system.get_center_of_mass",\
    capi_kwlist,&q_capi,&natoms_capi,&nbeads_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable q */
  q_Dims[0]=3;
  capi_q_intent |= F2PY_INTENT_IN;
  capi_q_tmp = array_from_pyobj(NPY_DOUBLE,q_Dims,q_Rank,capi_q_intent,q_capi);
  if (capi_q_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `q' of _main.system.get_center_of_mass to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    q = (double *)(PyArray_DATA(capi_q_tmp));

  /* Processing variable cm */
  cm_Dims[0]=3;
  capi_cm_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_cm_tmp = array_from_pyobj(NPY_DOUBLE,cm_Dims,cm_Rank,capi_cm_intent,Py_None);
  if (capi_cm_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `cm' of _main.system.get_center_of_mass to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    cm = (double *)(PyArray_DATA(capi_cm_tmp));

  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(q,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.get_center_of_mass() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(q,1)==natoms,"shape(q,1)==natoms","1st keyword natoms","get_center_of_mass:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(q,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.get_center_of_mass() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(q,2)==nbeads,"shape(q,2)==nbeads","2nd keyword nbeads","get_center_of_mass:nbeads=%d",nbeads) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(q,&natoms,&nbeads,cm);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_cm_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(q,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(q,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  }  /*if (capi_cm_tmp == NULL) ... else of cm*/
  /* End of cleaning variable cm */
  if((PyObject *)capi_q_tmp!=q_capi) {
    Py_XDECREF(capi_q_tmp); }
  }  /*if (capi_q_tmp == NULL) ... else of q*/
  /* End of cleaning variable q */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************* end of get_center_of_mass *************************/

/******************************** get_centroid ********************************/
static char doc_f2py_rout__main_system_get_centroid[] = "\
centroid = get_centroid(q,[natoms,nbeads])\n\nWrapper for ``get_centroid``.\
\n\nParameters\n----------\n"
"q : input rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(q,1)\n"
"nbeads : input int, optional\n    Default: shape(q,2)\n"
"\nReturns\n-------\n"
"centroid : rank-2 array('d') with bounds (3,natoms)";
/*  */
static PyObject *f2py_rout__main_system_get_centroid(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *q = NULL;
  npy_intp q_Dims[3] = {-1, -1, -1};
  const int q_Rank = 3;
  PyArrayObject *capi_q_tmp = NULL;
  int capi_q_intent = 0;
  PyObject *q_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  double *centroid = NULL;
  npy_intp centroid_Dims[2] = {-1, -1};
  const int centroid_Rank = 2;
  PyArrayObject *capi_centroid_tmp = NULL;
  int capi_centroid_intent = 0;
  static char *capi_kwlist[] = {"q","natoms","nbeads",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OO:_main.system.get_centroid",\
    capi_kwlist,&q_capi,&natoms_capi,&nbeads_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable q */
  q_Dims[0]=3;
  capi_q_intent |= F2PY_INTENT_IN;
  capi_q_tmp = array_from_pyobj(NPY_DOUBLE,q_Dims,q_Rank,capi_q_intent,q_capi);
  if (capi_q_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `q' of _main.system.get_centroid to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    q = (double *)(PyArray_DATA(capi_q_tmp));

  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(q,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.get_centroid() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(q,1)==natoms,"shape(q,1)==natoms","1st keyword natoms","get_centroid:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(q,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.get_centroid() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(q,2)==nbeads,"shape(q,2)==nbeads","2nd keyword nbeads","get_centroid:nbeads=%d",nbeads) {
  /* Processing variable centroid */
  centroid_Dims[0]=3,centroid_Dims[1]=natoms;
  capi_centroid_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_centroid_tmp = array_from_pyobj(NPY_DOUBLE,centroid_Dims,centroid_Rank,capi_centroid_intent,Py_None);
  if (capi_centroid_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `centroid' of _main.system.get_centroid to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    centroid = (double *)(PyArray_DATA(capi_centroid_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(q,&natoms,&nbeads,centroid);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_centroid_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_centroid_tmp == NULL) ... else of centroid*/
  /* End of cleaning variable centroid */
  } /*CHECKSCALAR(shape(q,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(q,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  if((PyObject *)capi_q_tmp!=q_capi) {
    Py_XDECREF(capi_q_tmp); }
  }  /*if (capi_q_tmp == NULL) ... else of q*/
  /* End of cleaning variable q */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of get_centroid ****************************/

/*************************** get_radius_of_gyration ***************************/
static char doc_f2py_rout__main_system_get_radius_of_gyration[] = "\
r = get_radius_of_gyration(q,[natoms,nbeads])\n\nWrapper for ``get_radius_of_gyration``.\
\n\nParameters\n----------\n"
"q : input rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(q,1)\n"
"nbeads : input int, optional\n    Default: shape(q,2)\n"
"\nReturns\n-------\n"
"r : rank-1 array('d') with bounds (natoms)";
/*  */
static PyObject *f2py_rout__main_system_get_radius_of_gyration(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *q = NULL;
  npy_intp q_Dims[3] = {-1, -1, -1};
  const int q_Rank = 3;
  PyArrayObject *capi_q_tmp = NULL;
  int capi_q_intent = 0;
  PyObject *q_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  double *r = NULL;
  npy_intp r_Dims[1] = {-1};
  const int r_Rank = 1;
  PyArrayObject *capi_r_tmp = NULL;
  int capi_r_intent = 0;
  static char *capi_kwlist[] = {"q","natoms","nbeads",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|OO:_main.system.get_radius_of_gyration",\
    capi_kwlist,&q_capi,&natoms_capi,&nbeads_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable q */
  q_Dims[0]=3;
  capi_q_intent |= F2PY_INTENT_IN;
  capi_q_tmp = array_from_pyobj(NPY_DOUBLE,q_Dims,q_Rank,capi_q_intent,q_capi);
  if (capi_q_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `q' of _main.system.get_radius_of_gyration to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    q = (double *)(PyArray_DATA(capi_q_tmp));

  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(q,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.get_radius_of_gyration() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(q,1)==natoms,"shape(q,1)==natoms","1st keyword natoms","get_radius_of_gyration:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(q,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.get_radius_of_gyration() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(q,2)==nbeads,"shape(q,2)==nbeads","2nd keyword nbeads","get_radius_of_gyration:nbeads=%d",nbeads) {
  /* Processing variable r */
  r_Dims[0]=natoms;
  capi_r_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_r_tmp = array_from_pyobj(NPY_DOUBLE,r_Dims,r_Rank,capi_r_intent,Py_None);
  if (capi_r_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `r' of _main.system.get_radius_of_gyration to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    r = (double *)(PyArray_DATA(capi_r_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(q,&natoms,&nbeads,r);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_r_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_r_tmp == NULL) ... else of r*/
  /* End of cleaning variable r */
  } /*CHECKSCALAR(shape(q,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(q,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  if((PyObject *)capi_q_tmp!=q_capi) {
    Py_XDECREF(capi_q_tmp); }
  }  /*if (capi_q_tmp == NULL) ... else of q*/
  /* End of cleaning variable q */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/*********************** end of get_radius_of_gyration ***********************/

/***************************** update_vmd_output *****************************/
static char doc_f2py_rout__main_system_update_vmd_output[] = "\
update_vmd_output(q,beads_file_number,centroid_file_number,[natoms,nbeads])\n\nWrapper for ``update_vmd_output``.\
\n\nParameters\n----------\n"
"q : input rank-3 array('d') with bounds (3,natoms,nbeads)\n"
"beads_file_number : input int\n"
"centroid_file_number : input int\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(q,1)\n"
"nbeads : input int, optional\n    Default: shape(q,2)";
/*  */
static PyObject *f2py_rout__main_system_update_vmd_output(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *q = NULL;
  npy_intp q_Dims[3] = {-1, -1, -1};
  const int q_Rank = 3;
  PyArrayObject *capi_q_tmp = NULL;
  int capi_q_intent = 0;
  PyObject *q_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  int nbeads = 0;
  PyObject *nbeads_capi = Py_None;
  int beads_file_number = 0;
  PyObject *beads_file_number_capi = Py_None;
  int centroid_file_number = 0;
  PyObject *centroid_file_number_capi = Py_None;
  static char *capi_kwlist[] = {"q","beads_file_number","centroid_file_number","natoms","nbeads",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO|OO:_main.system.update_vmd_output",\
    capi_kwlist,&q_capi,&beads_file_number_capi,&centroid_file_number_capi,&natoms_capi,&nbeads_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable q */
  q_Dims[0]=3;
  capi_q_intent |= F2PY_INTENT_IN;
  capi_q_tmp = array_from_pyobj(NPY_DOUBLE,q_Dims,q_Rank,capi_q_intent,q_capi);
  if (capi_q_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `q' of _main.system.update_vmd_output to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    q = (double *)(PyArray_DATA(capi_q_tmp));

  /* Processing variable beads_file_number */
    f2py_success = int_from_pyobj(&beads_file_number,beads_file_number_capi,"_main.system.update_vmd_output() 2nd argument (beads_file_number) can't be converted to int");
  if (f2py_success) {
  /* Processing variable centroid_file_number */
    f2py_success = int_from_pyobj(&centroid_file_number,centroid_file_number_capi,"_main.system.update_vmd_output() 3rd argument (centroid_file_number) can't be converted to int");
  if (f2py_success) {
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(q,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.system.update_vmd_output() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(q,1)==natoms,"shape(q,1)==natoms","1st keyword natoms","update_vmd_output:natoms=%d",natoms) {
  /* Processing variable nbeads */
  if (nbeads_capi == Py_None) nbeads = shape(q,2); else
    f2py_success = int_from_pyobj(&nbeads,nbeads_capi,"_main.system.update_vmd_output() 2nd keyword (nbeads) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(q,2)==nbeads,"shape(q,2)==nbeads","2nd keyword nbeads","update_vmd_output:nbeads=%d",nbeads) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(q,&natoms,&nbeads,&beads_file_number,&centroid_file_number);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(q,2)==nbeads)*/
  } /*if (f2py_success) of nbeads*/
  /* End of cleaning variable nbeads */
  } /*CHECKSCALAR(shape(q,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  } /*if (f2py_success) of centroid_file_number*/
  /* End of cleaning variable centroid_file_number */
  } /*if (f2py_success) of beads_file_number*/
  /* End of cleaning variable beads_file_number */
  if((PyObject *)capi_q_tmp!=q_capi) {
    Py_XDECREF(capi_q_tmp); }
  }  /*if (capi_q_tmp == NULL) ... else of q*/
  /* End of cleaning variable q */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/************************** end of update_vmd_output **************************/

/******************************** evaluate_all ********************************/
static char doc_f2py_rout__main_transition_state_evaluate_all[] = "\
values = evaluate_all(position,[natoms])\n\nWrapper for ``evaluate_all``.\
\n\nParameters\n----------\n"
"position : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(position,1)\n"
"\nReturns\n-------\n"
"values : rank-2 array('d') with bounds (f2py_values_d0,f2py_values_d1)";
/* #declfortranroutine# */
static PyObject *f2py_rout__main_transition_state_evaluate_all(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *position = NULL;
  npy_intp position_Dims[2] = {-1, -1};
  const int position_Rank = 2;
  PyArrayObject *capi_position_tmp = NULL;
  int capi_position_intent = 0;
  PyObject *position_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  double *values = NULL;
  npy_intp values_Dims[2] = {-1, -1};
  const int values_Rank = 2;
  PyArrayObject *capi_values_tmp = NULL;
  int capi_values_intent = 0;
  int f2py_values_d0 = 0;
  int f2py_values_d1 = 0;
  static char *capi_kwlist[] = {"position","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.transition_state.evaluate_all",\
    capi_kwlist,&position_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable position */
  position_Dims[0]=3;
  capi_position_intent |= F2PY_INTENT_IN;
  capi_position_tmp = array_from_pyobj(NPY_DOUBLE,position_Dims,position_Rank,capi_position_intent,position_capi);
  if (capi_position_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `position' of _main.transition_state.evaluate_all to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    position = (double *)(PyArray_DATA(capi_position_tmp));

  /* Processing variable values */
  ;
  capi_values_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_values_tmp = array_from_pyobj(NPY_DOUBLE,values_Dims,values_Rank,capi_values_intent,Py_None);
  if (capi_values_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `values' of _main.transition_state.evaluate_all to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    values = (double *)(PyArray_DATA(capi_values_tmp));

  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(position,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.transition_state.evaluate_all() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(position,1)==natoms,"shape(position,1)==natoms","1st keyword natoms","evaluate_all:natoms=%d",natoms) {
  /* Processing variable f2py_values_d0 */
  f2py_values_d0 = shape(values, 0);
  /* Processing variable f2py_values_d1 */
  f2py_values_d1 = shape(values, 1);
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(position,&natoms,values,&f2py_values_d0,&f2py_values_d1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_values_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable f2py_values_d1 */
  /* End of cleaning variable f2py_values_d0 */
  } /*CHECKSCALAR(shape(position,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  }  /*if (capi_values_tmp == NULL) ... else of values*/
  /* End of cleaning variable values */
  if((PyObject *)capi_position_tmp!=position_capi) {
    Py_XDECREF(capi_position_tmp); }
  }  /*if (capi_position_tmp == NULL) ... else of position*/
  /* End of cleaning variable position */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of evaluate_all ****************************/

/*********************************** value ***********************************/
static char doc_f2py_rout__main_transition_state_value[] = "\
s1 = value(position,[natoms])\n\nWrapper for ``value``.\
\n\nParameters\n----------\n"
"position : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(position,1)\n"
"\nReturns\n-------\n"
"s1 : float";
/*  */
static PyObject *f2py_rout__main_transition_state_value(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *position = NULL;
  npy_intp position_Dims[2] = {-1, -1};
  const int position_Rank = 2;
  PyArrayObject *capi_position_tmp = NULL;
  int capi_position_intent = 0;
  PyObject *position_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  double s1 = 0;
  static char *capi_kwlist[] = {"position","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.transition_state.value",\
    capi_kwlist,&position_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable position */
  position_Dims[0]=3;
  capi_position_intent |= F2PY_INTENT_IN;
  capi_position_tmp = array_from_pyobj(NPY_DOUBLE,position_Dims,position_Rank,capi_position_intent,position_capi);
  if (capi_position_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `position' of _main.transition_state.value to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    position = (double *)(PyArray_DATA(capi_position_tmp));

  /* Processing variable s1 */
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(position,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.transition_state.value() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(position,1)==natoms,"shape(position,1)==natoms","1st keyword natoms","value:natoms=%d",natoms) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(position,&natoms,&s1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",s1);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(position,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  /* End of cleaning variable s1 */
  if((PyObject *)capi_position_tmp!=position_capi) {
    Py_XDECREF(capi_position_tmp); }
  }  /*if (capi_position_tmp == NULL) ... else of position*/
  /* End of cleaning variable position */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of value ********************************/

/********************************** gradient **********************************/
static char doc_f2py_rout__main_transition_state_gradient[] = "\
ds1 = gradient(position,[natoms])\n\nWrapper for ``gradient``.\
\n\nParameters\n----------\n"
"position : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(position,1)\n"
"\nReturns\n-------\n"
"ds1 : rank-2 array('d') with bounds (3,natoms)";
/*  */
static PyObject *f2py_rout__main_transition_state_gradient(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *position = NULL;
  npy_intp position_Dims[2] = {-1, -1};
  const int position_Rank = 2;
  PyArrayObject *capi_position_tmp = NULL;
  int capi_position_intent = 0;
  PyObject *position_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  double *ds1 = NULL;
  npy_intp ds1_Dims[2] = {-1, -1};
  const int ds1_Rank = 2;
  PyArrayObject *capi_ds1_tmp = NULL;
  int capi_ds1_intent = 0;
  static char *capi_kwlist[] = {"position","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.transition_state.gradient",\
    capi_kwlist,&position_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable position */
  position_Dims[0]=3;
  capi_position_intent |= F2PY_INTENT_IN;
  capi_position_tmp = array_from_pyobj(NPY_DOUBLE,position_Dims,position_Rank,capi_position_intent,position_capi);
  if (capi_position_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `position' of _main.transition_state.gradient to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    position = (double *)(PyArray_DATA(capi_position_tmp));

  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(position,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.transition_state.gradient() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(position,1)==natoms,"shape(position,1)==natoms","1st keyword natoms","gradient:natoms=%d",natoms) {
  /* Processing variable ds1 */
  ds1_Dims[0]=3,ds1_Dims[1]=natoms;
  capi_ds1_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_ds1_tmp = array_from_pyobj(NPY_DOUBLE,ds1_Dims,ds1_Rank,capi_ds1_intent,Py_None);
  if (capi_ds1_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `ds1' of _main.transition_state.gradient to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    ds1 = (double *)(PyArray_DATA(capi_ds1_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(position,&natoms,ds1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_ds1_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_ds1_tmp == NULL) ... else of ds1*/
  /* End of cleaning variable ds1 */
  } /*CHECKSCALAR(shape(position,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  if((PyObject *)capi_position_tmp!=position_capi) {
    Py_XDECREF(capi_position_tmp); }
  }  /*if (capi_position_tmp == NULL) ... else of position*/
  /* End of cleaning variable position */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of gradient ******************************/

/********************************** hessian **********************************/
static char doc_f2py_rout__main_transition_state_hessian[] = "\
d2s1 = hessian(position,[natoms])\n\nWrapper for ``hessian``.\
\n\nParameters\n----------\n"
"position : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(position,1)\n"
"\nReturns\n-------\n"
"d2s1 : rank-4 array('d') with bounds (3,natoms,3,natoms)";
/*  */
static PyObject *f2py_rout__main_transition_state_hessian(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *position = NULL;
  npy_intp position_Dims[2] = {-1, -1};
  const int position_Rank = 2;
  PyArrayObject *capi_position_tmp = NULL;
  int capi_position_intent = 0;
  PyObject *position_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  double *d2s1 = NULL;
  npy_intp d2s1_Dims[4] = {-1, -1, -1, -1};
  const int d2s1_Rank = 4;
  PyArrayObject *capi_d2s1_tmp = NULL;
  int capi_d2s1_intent = 0;
  static char *capi_kwlist[] = {"position","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.transition_state.hessian",\
    capi_kwlist,&position_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable position */
  position_Dims[0]=3;
  capi_position_intent |= F2PY_INTENT_IN;
  capi_position_tmp = array_from_pyobj(NPY_DOUBLE,position_Dims,position_Rank,capi_position_intent,position_capi);
  if (capi_position_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `position' of _main.transition_state.hessian to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    position = (double *)(PyArray_DATA(capi_position_tmp));

  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(position,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.transition_state.hessian() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(position,1)==natoms,"shape(position,1)==natoms","1st keyword natoms","hessian:natoms=%d",natoms) {
  /* Processing variable d2s1 */
  d2s1_Dims[0]=3,d2s1_Dims[1]=natoms,d2s1_Dims[2]=3,d2s1_Dims[3]=natoms;
  capi_d2s1_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_d2s1_tmp = array_from_pyobj(NPY_DOUBLE,d2s1_Dims,d2s1_Rank,capi_d2s1_intent,Py_None);
  if (capi_d2s1_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `d2s1' of _main.transition_state.hessian to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    d2s1 = (double *)(PyArray_DATA(capi_d2s1_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(position,&natoms,d2s1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_d2s1_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_d2s1_tmp == NULL) ... else of d2s1*/
  /* End of cleaning variable d2s1 */
  } /*CHECKSCALAR(shape(position,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  if((PyObject *)capi_position_tmp!=position_capi) {
    Py_XDECREF(capi_position_tmp); }
  }  /*if (capi_position_tmp == NULL) ... else of position*/
  /* End of cleaning variable position */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of hessian *******************************/

/********************************** evaluate **********************************/
static char doc_f2py_rout__main_transition_state_evaluate[] = "\
s1,ds1,d2s1 = evaluate(position,[natoms])\n\nWrapper for ``evaluate``.\
\n\nParameters\n----------\n"
"position : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(position,1)\n"
"\nReturns\n-------\n"
"s1 : float\n"
"ds1 : rank-2 array('d') with bounds (3,natoms)\n"
"d2s1 : rank-4 array('d') with bounds (3,natoms,3,natoms)";
/*  */
static PyObject *f2py_rout__main_transition_state_evaluate(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *position = NULL;
  npy_intp position_Dims[2] = {-1, -1};
  const int position_Rank = 2;
  PyArrayObject *capi_position_tmp = NULL;
  int capi_position_intent = 0;
  PyObject *position_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  double s1 = 0;
  double *ds1 = NULL;
  npy_intp ds1_Dims[2] = {-1, -1};
  const int ds1_Rank = 2;
  PyArrayObject *capi_ds1_tmp = NULL;
  int capi_ds1_intent = 0;
  double *d2s1 = NULL;
  npy_intp d2s1_Dims[4] = {-1, -1, -1, -1};
  const int d2s1_Rank = 4;
  PyArrayObject *capi_d2s1_tmp = NULL;
  int capi_d2s1_intent = 0;
  static char *capi_kwlist[] = {"position","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.transition_state.evaluate",\
    capi_kwlist,&position_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable position */
  position_Dims[0]=3;
  capi_position_intent |= F2PY_INTENT_IN;
  capi_position_tmp = array_from_pyobj(NPY_DOUBLE,position_Dims,position_Rank,capi_position_intent,position_capi);
  if (capi_position_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `position' of _main.transition_state.evaluate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    position = (double *)(PyArray_DATA(capi_position_tmp));

  /* Processing variable s1 */
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(position,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.transition_state.evaluate() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(position,1)==natoms,"shape(position,1)==natoms","1st keyword natoms","evaluate:natoms=%d",natoms) {
  /* Processing variable ds1 */
  ds1_Dims[0]=3,ds1_Dims[1]=natoms;
  capi_ds1_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_ds1_tmp = array_from_pyobj(NPY_DOUBLE,ds1_Dims,ds1_Rank,capi_ds1_intent,Py_None);
  if (capi_ds1_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `ds1' of _main.transition_state.evaluate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    ds1 = (double *)(PyArray_DATA(capi_ds1_tmp));

  /* Processing variable d2s1 */
  d2s1_Dims[0]=3,d2s1_Dims[1]=natoms,d2s1_Dims[2]=3,d2s1_Dims[3]=natoms;
  capi_d2s1_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_d2s1_tmp = array_from_pyobj(NPY_DOUBLE,d2s1_Dims,d2s1_Rank,capi_d2s1_intent,Py_None);
  if (capi_d2s1_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `d2s1' of _main.transition_state.evaluate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    d2s1 = (double *)(PyArray_DATA(capi_d2s1_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(position,&natoms,&s1,ds1,d2s1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("dNN",s1,capi_ds1_tmp,capi_d2s1_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_d2s1_tmp == NULL) ... else of d2s1*/
  /* End of cleaning variable d2s1 */
  }  /*if (capi_ds1_tmp == NULL) ... else of ds1*/
  /* End of cleaning variable ds1 */
  } /*CHECKSCALAR(shape(position,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  /* End of cleaning variable s1 */
  if((PyObject *)capi_position_tmp!=position_capi) {
    Py_XDECREF(capi_position_tmp); }
  }  /*if (capi_position_tmp == NULL) ... else of position*/
  /* End of cleaning variable position */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of evaluate ******************************/

/************************** reactant1_center_of_mass **************************/
static char doc_f2py_rout__main_reactants_reactant1_center_of_mass[] = "\
cm = reactant1_center_of_mass(position,[natoms])\n\nWrapper for ``reactant1_center_of_mass``.\
\n\nParameters\n----------\n"
"position : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(position,1)\n"
"\nReturns\n-------\n"
"cm : rank-1 array('d') with bounds (3)";
/*  */
static PyObject *f2py_rout__main_reactants_reactant1_center_of_mass(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *position = NULL;
  npy_intp position_Dims[2] = {-1, -1};
  const int position_Rank = 2;
  PyArrayObject *capi_position_tmp = NULL;
  int capi_position_intent = 0;
  PyObject *position_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  double *cm = NULL;
  npy_intp cm_Dims[1] = {-1};
  const int cm_Rank = 1;
  PyArrayObject *capi_cm_tmp = NULL;
  int capi_cm_intent = 0;
  static char *capi_kwlist[] = {"position","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.reactants.reactant1_center_of_mass",\
    capi_kwlist,&position_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable position */
  position_Dims[0]=3;
  capi_position_intent |= F2PY_INTENT_IN;
  capi_position_tmp = array_from_pyobj(NPY_DOUBLE,position_Dims,position_Rank,capi_position_intent,position_capi);
  if (capi_position_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `position' of _main.reactants.reactant1_center_of_mass to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    position = (double *)(PyArray_DATA(capi_position_tmp));

  /* Processing variable cm */
  cm_Dims[0]=3;
  capi_cm_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_cm_tmp = array_from_pyobj(NPY_DOUBLE,cm_Dims,cm_Rank,capi_cm_intent,Py_None);
  if (capi_cm_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `cm' of _main.reactants.reactant1_center_of_mass to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    cm = (double *)(PyArray_DATA(capi_cm_tmp));

  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(position,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.reactants.reactant1_center_of_mass() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(position,1)==natoms,"shape(position,1)==natoms","1st keyword natoms","reactant1_center_of_mass:natoms=%d",natoms) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(position,&natoms,cm);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_cm_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(position,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  }  /*if (capi_cm_tmp == NULL) ... else of cm*/
  /* End of cleaning variable cm */
  if((PyObject *)capi_position_tmp!=position_capi) {
    Py_XDECREF(capi_position_tmp); }
  }  /*if (capi_position_tmp == NULL) ... else of position*/
  /* End of cleaning variable position */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/********************** end of reactant1_center_of_mass **********************/

/************************** reactant2_center_of_mass **************************/
static char doc_f2py_rout__main_reactants_reactant2_center_of_mass[] = "\
cm = reactant2_center_of_mass(position,[natoms])\n\nWrapper for ``reactant2_center_of_mass``.\
\n\nParameters\n----------\n"
"position : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(position,1)\n"
"\nReturns\n-------\n"
"cm : rank-1 array('d') with bounds (3)";
/*  */
static PyObject *f2py_rout__main_reactants_reactant2_center_of_mass(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *position = NULL;
  npy_intp position_Dims[2] = {-1, -1};
  const int position_Rank = 2;
  PyArrayObject *capi_position_tmp = NULL;
  int capi_position_intent = 0;
  PyObject *position_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  double *cm = NULL;
  npy_intp cm_Dims[1] = {-1};
  const int cm_Rank = 1;
  PyArrayObject *capi_cm_tmp = NULL;
  int capi_cm_intent = 0;
  static char *capi_kwlist[] = {"position","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.reactants.reactant2_center_of_mass",\
    capi_kwlist,&position_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable position */
  position_Dims[0]=3;
  capi_position_intent |= F2PY_INTENT_IN;
  capi_position_tmp = array_from_pyobj(NPY_DOUBLE,position_Dims,position_Rank,capi_position_intent,position_capi);
  if (capi_position_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `position' of _main.reactants.reactant2_center_of_mass to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    position = (double *)(PyArray_DATA(capi_position_tmp));

  /* Processing variable cm */
  cm_Dims[0]=3;
  capi_cm_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_cm_tmp = array_from_pyobj(NPY_DOUBLE,cm_Dims,cm_Rank,capi_cm_intent,Py_None);
  if (capi_cm_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `cm' of _main.reactants.reactant2_center_of_mass to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    cm = (double *)(PyArray_DATA(capi_cm_tmp));

  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(position,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.reactants.reactant2_center_of_mass() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(position,1)==natoms,"shape(position,1)==natoms","1st keyword natoms","reactant2_center_of_mass:natoms=%d",natoms) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(position,&natoms,cm);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_cm_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(position,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  }  /*if (capi_cm_tmp == NULL) ... else of cm*/
  /* End of cleaning variable cm */
  if((PyObject *)capi_position_tmp!=position_capi) {
    Py_XDECREF(capi_position_tmp); }
  }  /*if (capi_position_tmp == NULL) ... else of position*/
  /* End of cleaning variable position */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/********************** end of reactant2_center_of_mass **********************/

/*********************************** value ***********************************/
static char doc_f2py_rout__main_reactants_value[] = "\
s0 = value(position,[natoms])\n\nWrapper for ``value``.\
\n\nParameters\n----------\n"
"position : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(position,1)\n"
"\nReturns\n-------\n"
"s0 : float";
/*  */
static PyObject *f2py_rout__main_reactants_value(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *position = NULL;
  npy_intp position_Dims[2] = {-1, -1};
  const int position_Rank = 2;
  PyArrayObject *capi_position_tmp = NULL;
  int capi_position_intent = 0;
  PyObject *position_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  double s0 = 0;
  static char *capi_kwlist[] = {"position","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.reactants.value",\
    capi_kwlist,&position_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable position */
  position_Dims[0]=3;
  capi_position_intent |= F2PY_INTENT_IN;
  capi_position_tmp = array_from_pyobj(NPY_DOUBLE,position_Dims,position_Rank,capi_position_intent,position_capi);
  if (capi_position_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `position' of _main.reactants.value to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    position = (double *)(PyArray_DATA(capi_position_tmp));

  /* Processing variable s0 */
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(position,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.reactants.value() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(position,1)==natoms,"shape(position,1)==natoms","1st keyword natoms","value:natoms=%d",natoms) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(position,&natoms,&s0);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("d",s0);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*CHECKSCALAR(shape(position,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  /* End of cleaning variable s0 */
  if((PyObject *)capi_position_tmp!=position_capi) {
    Py_XDECREF(capi_position_tmp); }
  }  /*if (capi_position_tmp == NULL) ... else of position*/
  /* End of cleaning variable position */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of value ********************************/

/********************************** gradient **********************************/
static char doc_f2py_rout__main_reactants_gradient[] = "\
ds0 = gradient(position,[natoms])\n\nWrapper for ``gradient``.\
\n\nParameters\n----------\n"
"position : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(position,1)\n"
"\nReturns\n-------\n"
"ds0 : rank-2 array('d') with bounds (3,natoms)";
/*  */
static PyObject *f2py_rout__main_reactants_gradient(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *position = NULL;
  npy_intp position_Dims[2] = {-1, -1};
  const int position_Rank = 2;
  PyArrayObject *capi_position_tmp = NULL;
  int capi_position_intent = 0;
  PyObject *position_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  double *ds0 = NULL;
  npy_intp ds0_Dims[2] = {-1, -1};
  const int ds0_Rank = 2;
  PyArrayObject *capi_ds0_tmp = NULL;
  int capi_ds0_intent = 0;
  static char *capi_kwlist[] = {"position","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.reactants.gradient",\
    capi_kwlist,&position_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable position */
  position_Dims[0]=3;
  capi_position_intent |= F2PY_INTENT_IN;
  capi_position_tmp = array_from_pyobj(NPY_DOUBLE,position_Dims,position_Rank,capi_position_intent,position_capi);
  if (capi_position_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `position' of _main.reactants.gradient to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    position = (double *)(PyArray_DATA(capi_position_tmp));

  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(position,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.reactants.gradient() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(position,1)==natoms,"shape(position,1)==natoms","1st keyword natoms","gradient:natoms=%d",natoms) {
  /* Processing variable ds0 */
  ds0_Dims[0]=3,ds0_Dims[1]=natoms;
  capi_ds0_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_ds0_tmp = array_from_pyobj(NPY_DOUBLE,ds0_Dims,ds0_Rank,capi_ds0_intent,Py_None);
  if (capi_ds0_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `ds0' of _main.reactants.gradient to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    ds0 = (double *)(PyArray_DATA(capi_ds0_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(position,&natoms,ds0);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_ds0_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_ds0_tmp == NULL) ... else of ds0*/
  /* End of cleaning variable ds0 */
  } /*CHECKSCALAR(shape(position,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  if((PyObject *)capi_position_tmp!=position_capi) {
    Py_XDECREF(capi_position_tmp); }
  }  /*if (capi_position_tmp == NULL) ... else of position*/
  /* End of cleaning variable position */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of gradient ******************************/

/********************************** hessian **********************************/
static char doc_f2py_rout__main_reactants_hessian[] = "\
d2s0 = hessian(position,[natoms])\n\nWrapper for ``hessian``.\
\n\nParameters\n----------\n"
"position : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(position,1)\n"
"\nReturns\n-------\n"
"d2s0 : rank-4 array('d') with bounds (3,natoms,3,natoms)";
/*  */
static PyObject *f2py_rout__main_reactants_hessian(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *position = NULL;
  npy_intp position_Dims[2] = {-1, -1};
  const int position_Rank = 2;
  PyArrayObject *capi_position_tmp = NULL;
  int capi_position_intent = 0;
  PyObject *position_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  double *d2s0 = NULL;
  npy_intp d2s0_Dims[4] = {-1, -1, -1, -1};
  const int d2s0_Rank = 4;
  PyArrayObject *capi_d2s0_tmp = NULL;
  int capi_d2s0_intent = 0;
  static char *capi_kwlist[] = {"position","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.reactants.hessian",\
    capi_kwlist,&position_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable position */
  position_Dims[0]=3;
  capi_position_intent |= F2PY_INTENT_IN;
  capi_position_tmp = array_from_pyobj(NPY_DOUBLE,position_Dims,position_Rank,capi_position_intent,position_capi);
  if (capi_position_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `position' of _main.reactants.hessian to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    position = (double *)(PyArray_DATA(capi_position_tmp));

  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(position,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.reactants.hessian() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(position,1)==natoms,"shape(position,1)==natoms","1st keyword natoms","hessian:natoms=%d",natoms) {
  /* Processing variable d2s0 */
  d2s0_Dims[0]=3,d2s0_Dims[1]=natoms,d2s0_Dims[2]=3,d2s0_Dims[3]=natoms;
  capi_d2s0_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_d2s0_tmp = array_from_pyobj(NPY_DOUBLE,d2s0_Dims,d2s0_Rank,capi_d2s0_intent,Py_None);
  if (capi_d2s0_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `d2s0' of _main.reactants.hessian to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    d2s0 = (double *)(PyArray_DATA(capi_d2s0_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(position,&natoms,d2s0);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("N",capi_d2s0_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_d2s0_tmp == NULL) ... else of d2s0*/
  /* End of cleaning variable d2s0 */
  } /*CHECKSCALAR(shape(position,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  if((PyObject *)capi_position_tmp!=position_capi) {
    Py_XDECREF(capi_position_tmp); }
  }  /*if (capi_position_tmp == NULL) ... else of position*/
  /* End of cleaning variable position */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of hessian *******************************/

/********************************** evaluate **********************************/
static char doc_f2py_rout__main_reactants_evaluate[] = "\
s1,ds1,d2s1 = evaluate(position,[natoms])\n\nWrapper for ``evaluate``.\
\n\nParameters\n----------\n"
"position : input rank-2 array('d') with bounds (3,natoms)\n"
"\nOther Parameters\n----------------\n"
"natoms : input int, optional\n    Default: shape(position,1)\n"
"\nReturns\n-------\n"
"s1 : float\n"
"ds1 : rank-2 array('d') with bounds (3,natoms)\n"
"d2s1 : rank-4 array('d') with bounds (3,natoms,3,natoms)";
/*  */
static PyObject *f2py_rout__main_reactants_evaluate(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,int*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double *position = NULL;
  npy_intp position_Dims[2] = {-1, -1};
  const int position_Rank = 2;
  PyArrayObject *capi_position_tmp = NULL;
  int capi_position_intent = 0;
  PyObject *position_capi = Py_None;
  int natoms = 0;
  PyObject *natoms_capi = Py_None;
  double s1 = 0;
  double *ds1 = NULL;
  npy_intp ds1_Dims[2] = {-1, -1};
  const int ds1_Rank = 2;
  PyArrayObject *capi_ds1_tmp = NULL;
  int capi_ds1_intent = 0;
  double *d2s1 = NULL;
  npy_intp d2s1_Dims[4] = {-1, -1, -1, -1};
  const int d2s1_Rank = 4;
  PyArrayObject *capi_d2s1_tmp = NULL;
  int capi_d2s1_intent = 0;
  static char *capi_kwlist[] = {"position","natoms",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O|O:_main.reactants.evaluate",\
    capi_kwlist,&position_capi,&natoms_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable position */
  position_Dims[0]=3;
  capi_position_intent |= F2PY_INTENT_IN;
  capi_position_tmp = array_from_pyobj(NPY_DOUBLE,position_Dims,position_Rank,capi_position_intent,position_capi);
  if (capi_position_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting 1st argument `position' of _main.reactants.evaluate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    position = (double *)(PyArray_DATA(capi_position_tmp));

  /* Processing variable s1 */
  /* Processing variable natoms */
  if (natoms_capi == Py_None) natoms = shape(position,1); else
    f2py_success = int_from_pyobj(&natoms,natoms_capi,"_main.reactants.evaluate() 1st keyword (natoms) can't be converted to int");
  if (f2py_success) {
  CHECKSCALAR(shape(position,1)==natoms,"shape(position,1)==natoms","1st keyword natoms","evaluate:natoms=%d",natoms) {
  /* Processing variable ds1 */
  ds1_Dims[0]=3,ds1_Dims[1]=natoms;
  capi_ds1_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_ds1_tmp = array_from_pyobj(NPY_DOUBLE,ds1_Dims,ds1_Rank,capi_ds1_intent,Py_None);
  if (capi_ds1_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `ds1' of _main.reactants.evaluate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    ds1 = (double *)(PyArray_DATA(capi_ds1_tmp));

  /* Processing variable d2s1 */
  d2s1_Dims[0]=3,d2s1_Dims[1]=natoms,d2s1_Dims[2]=3,d2s1_Dims[3]=natoms;
  capi_d2s1_intent |= F2PY_INTENT_OUT|F2PY_INTENT_HIDE;
  capi_d2s1_tmp = array_from_pyobj(NPY_DOUBLE,d2s1_Dims,d2s1_Rank,capi_d2s1_intent,Py_None);
  if (capi_d2s1_tmp == NULL) {
    PyObject *exc, *val, *tb;
    PyErr_Fetch(&exc, &val, &tb);
    PyErr_SetString(exc ? exc : _main_error,"failed in converting hidden `d2s1' of _main.reactants.evaluate to C/Fortran array" );
    npy_PyErr_ChainExceptionsCause(exc, val, tb);
  } else {
    d2s1 = (double *)(PyArray_DATA(capi_d2s1_tmp));

/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(position,&natoms,&s1,ds1,d2s1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("dNN",s1,capi_ds1_tmp,capi_d2s1_tmp);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (capi_d2s1_tmp == NULL) ... else of d2s1*/
  /* End of cleaning variable d2s1 */
  }  /*if (capi_ds1_tmp == NULL) ... else of ds1*/
  /* End of cleaning variable ds1 */
  } /*CHECKSCALAR(shape(position,1)==natoms)*/
  } /*if (f2py_success) of natoms*/
  /* End of cleaning variable natoms */
  /* End of cleaning variable s1 */
  if((PyObject *)capi_position_tmp!=position_capi) {
    Py_XDECREF(capi_position_tmp); }
  }  /*if (capi_position_tmp == NULL) ... else of position*/
  /* End of cleaning variable position */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of evaluate ******************************/
/*eof body*/

/******************* See f2py2e/f90mod_rules.py: buildhooks *******************/

static FortranDataDef f2py_system_def[] = {
  {"beta",0,{{-1}},NPY_DOUBLE},
  {"mass",1,{{100}},NPY_DOUBLE},
  {"mode",0,{{-1}},NPY_INT},
  {"max_atoms",0,{{-1}},NPY_INT},
  {"dt",0,{{-1}},NPY_DOUBLE},
  {"pi",0,{{-1}},NPY_DOUBLE},
  {"thermostat",0,{{-1}},NPY_INT},
  {"andersen_sampling_time",0,{{-1}},NPY_DOUBLE},
  {"max_gle_ns",0,{{-1}},NPY_INT},
  {"gle_ns",0,{{-1}},NPY_INT},
  {"gle_a",2,{{21,21}},NPY_DOUBLE},
  {"gle_c",2,{{21,21}},NPY_DOUBLE},
  {"equilibrate",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_equilibrate,doc_f2py_rout__main_system_equilibrate},
  {"recrossing_trajectory",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_recrossing_trajectory,doc_f2py_rout__main_system_recrossing_trajectory},
  {"umbrella_trajectory",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_umbrella_trajectory,doc_f2py_rout__main_system_umbrella_trajectory},
  {"verlet_step",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_verlet_step,doc_f2py_rout__main_system_verlet_step},
  {"free_ring_polymer_step",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_free_ring_polymer_step,doc_f2py_rout__main_system_free_ring_polymer_step},
  {"constrain_to_dividing_surface",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_constrain_to_dividing_surface,doc_f2py_rout__main_system_constrain_to_dividing_surface},
  {"constrain_momentum_to_dividing_surface",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_constrain_momentum_to_dividing_surface,doc_f2py_rout__main_system_constrain_momentum_to_dividing_surface},
  {"add_umbrella_potential",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_add_umbrella_potential,doc_f2py_rout__main_system_add_umbrella_potential},
  {"add_bias_potential",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_add_bias_potential,doc_f2py_rout__main_system_add_bias_potential},
  {"get_reaction_coordinate",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_get_reaction_coordinate,doc_f2py_rout__main_system_get_reaction_coordinate},
  {"get_recrossing_flux",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_get_recrossing_flux,doc_f2py_rout__main_system_get_recrossing_flux},
  {"get_recrossing_velocity",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_get_recrossing_velocity,doc_f2py_rout__main_system_get_recrossing_velocity},
  {"sample_momentum",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_sample_momentum,doc_f2py_rout__main_system_sample_momentum},
  {"get_ring_polymer_energy",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_get_ring_polymer_energy,doc_f2py_rout__main_system_get_ring_polymer_energy},
  {"get_kinetic_energy",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_get_kinetic_energy,doc_f2py_rout__main_system_get_kinetic_energy},
  {"get_center_of_mass",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_get_center_of_mass,doc_f2py_rout__main_system_get_center_of_mass},
  {"get_centroid",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_get_centroid,doc_f2py_rout__main_system_get_centroid},
  {"get_radius_of_gyration",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_get_radius_of_gyration,doc_f2py_rout__main_system_get_radius_of_gyration},
  {"update_vmd_output",-1,{{-1}},0,NULL,(void *)f2py_rout__main_system_update_vmd_output,doc_f2py_rout__main_system_update_vmd_output},
  {NULL}
};

static void f2py_setup_system(char *beta,char *mass,char *mode,char *max_atoms,char *dt,char *pi,char *thermostat,char *andersen_sampling_time,char *max_gle_ns,char *gle_ns,char *gle_a,char *gle_c,char *equilibrate,char *recrossing_trajectory,char *umbrella_trajectory,char *verlet_step,char *free_ring_polymer_step,char *constrain_to_dividing_surface,char *constrain_momentum_to_dividing_surface,char *add_umbrella_potential,char *add_bias_potential,char *get_reaction_coordinate,char *get_recrossing_flux,char *get_recrossing_velocity,char *sample_momentum,char *get_ring_polymer_energy,char *get_kinetic_energy,char *get_center_of_mass,char *get_centroid,char *get_radius_of_gyration,char *update_vmd_output) {
  int i_f2py=0;
  f2py_system_def[i_f2py++].data = beta;
  f2py_system_def[i_f2py++].data = mass;
  f2py_system_def[i_f2py++].data = mode;
  f2py_system_def[i_f2py++].data = max_atoms;
  f2py_system_def[i_f2py++].data = dt;
  f2py_system_def[i_f2py++].data = pi;
  f2py_system_def[i_f2py++].data = thermostat;
  f2py_system_def[i_f2py++].data = andersen_sampling_time;
  f2py_system_def[i_f2py++].data = max_gle_ns;
  f2py_system_def[i_f2py++].data = gle_ns;
  f2py_system_def[i_f2py++].data = gle_a;
  f2py_system_def[i_f2py++].data = gle_c;
  f2py_system_def[i_f2py++].data = equilibrate;
  f2py_system_def[i_f2py++].data = recrossing_trajectory;
  f2py_system_def[i_f2py++].data = umbrella_trajectory;
  f2py_system_def[i_f2py++].data = verlet_step;
  f2py_system_def[i_f2py++].data = free_ring_polymer_step;
  f2py_system_def[i_f2py++].data = constrain_to_dividing_surface;
  f2py_system_def[i_f2py++].data = constrain_momentum_to_dividing_surface;
  f2py_system_def[i_f2py++].data = add_umbrella_potential;
  f2py_system_def[i_f2py++].data = add_bias_potential;
  f2py_system_def[i_f2py++].data = get_reaction_coordinate;
  f2py_system_def[i_f2py++].data = get_recrossing_flux;
  f2py_system_def[i_f2py++].data = get_recrossing_velocity;
  f2py_system_def[i_f2py++].data = sample_momentum;
  f2py_system_def[i_f2py++].data = get_ring_polymer_energy;
  f2py_system_def[i_f2py++].data = get_kinetic_energy;
  f2py_system_def[i_f2py++].data = get_center_of_mass;
  f2py_system_def[i_f2py++].data = get_centroid;
  f2py_system_def[i_f2py++].data = get_radius_of_gyration;
  f2py_system_def[i_f2py++].data = update_vmd_output;
}
extern void F_FUNC(f2pyinitsystem,F2PYINITSYSTEM)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *,char *));
static void f2py_init_system(void) {
  F_FUNC(f2pyinitsystem,F2PYINITSYSTEM)(f2py_setup_system);
}


static FortranDataDef f2py_transition_state_def[] = {
  {"max_ts",0,{{-1}},NPY_INT},
  {"max_atoms",0,{{-1}},NPY_INT},
  {"number_of_bonds",0,{{-1}},NPY_INT},
  {"forming_bond_lengths",2,{{16,16}},NPY_DOUBLE},
  {"breaking_bond_lengths",2,{{16,16}},NPY_DOUBLE},
  {"max_bonds",0,{{-1}},NPY_INT},
  {"number_of_transition_states",0,{{-1}},NPY_INT},
  {"breaking_bonds",3,{{16,16,2}},NPY_INT},
  {"forming_bonds",3,{{16,16,2}},NPY_INT},
  {"evaluate_all",-1,{{-1}},0,NULL,(void *)f2py_rout__main_transition_state_evaluate_all,doc_f2py_rout__main_transition_state_evaluate_all},
  {"value",-1,{{-1}},0,NULL,(void *)f2py_rout__main_transition_state_value,doc_f2py_rout__main_transition_state_value},
  {"gradient",-1,{{-1}},0,NULL,(void *)f2py_rout__main_transition_state_gradient,doc_f2py_rout__main_transition_state_gradient},
  {"hessian",-1,{{-1}},0,NULL,(void *)f2py_rout__main_transition_state_hessian,doc_f2py_rout__main_transition_state_hessian},
  {"evaluate",-1,{{-1}},0,NULL,(void *)f2py_rout__main_transition_state_evaluate,doc_f2py_rout__main_transition_state_evaluate},
  {NULL}
};

static void f2py_setup_transition_state(char *max_ts,char *max_atoms,char *number_of_bonds,char *forming_bond_lengths,char *breaking_bond_lengths,char *max_bonds,char *number_of_transition_states,char *breaking_bonds,char *forming_bonds,char *evaluate_all,char *value,char *gradient,char *hessian,char *evaluate) {
  int i_f2py=0;
  f2py_transition_state_def[i_f2py++].data = max_ts;
  f2py_transition_state_def[i_f2py++].data = max_atoms;
  f2py_transition_state_def[i_f2py++].data = number_of_bonds;
  f2py_transition_state_def[i_f2py++].data = forming_bond_lengths;
  f2py_transition_state_def[i_f2py++].data = breaking_bond_lengths;
  f2py_transition_state_def[i_f2py++].data = max_bonds;
  f2py_transition_state_def[i_f2py++].data = number_of_transition_states;
  f2py_transition_state_def[i_f2py++].data = breaking_bonds;
  f2py_transition_state_def[i_f2py++].data = forming_bonds;
  f2py_transition_state_def[i_f2py++].data = evaluate_all;
  f2py_transition_state_def[i_f2py++].data = value;
  f2py_transition_state_def[i_f2py++].data = gradient;
  f2py_transition_state_def[i_f2py++].data = hessian;
  f2py_transition_state_def[i_f2py++].data = evaluate;
}
extern void F_FUNC_US(f2pyinittransition_state,F2PYINITTRANSITION_STATE)(void (*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char *,char *,char *,char *,char *));
static void f2py_init_transition_state(void) {
  F_FUNC_US(f2pyinittransition_state,F2PYINITTRANSITION_STATE)(f2py_setup_transition_state);
}


static FortranDataDef f2py_reactants_def[] = {
  {"nreactant1_atoms",0,{{-1}},NPY_INT},
  {"reactant1_atoms",1,{{100}},NPY_INT},
  {"massfrac",1,{{100}},NPY_DOUBLE},
  {"nreactant2_atoms",0,{{-1}},NPY_INT},
  {"max_atoms",0,{{-1}},NPY_INT},
  {"rinf",0,{{-1}},NPY_DOUBLE},
  {"reactant2_atoms",1,{{100}},NPY_INT},
  {"reactant1_center_of_mass",-1,{{-1}},0,NULL,(void *)f2py_rout__main_reactants_reactant1_center_of_mass,doc_f2py_rout__main_reactants_reactant1_center_of_mass},
  {"reactant2_center_of_mass",-1,{{-1}},0,NULL,(void *)f2py_rout__main_reactants_reactant2_center_of_mass,doc_f2py_rout__main_reactants_reactant2_center_of_mass},
  {"value",-1,{{-1}},0,NULL,(void *)f2py_rout__main_reactants_value,doc_f2py_rout__main_reactants_value},
  {"gradient",-1,{{-1}},0,NULL,(void *)f2py_rout__main_reactants_gradient,doc_f2py_rout__main_reactants_gradient},
  {"hessian",-1,{{-1}},0,NULL,(void *)f2py_rout__main_reactants_hessian,doc_f2py_rout__main_reactants_hessian},
  {"evaluate",-1,{{-1}},0,NULL,(void *)f2py_rout__main_reactants_evaluate,doc_f2py_rout__main_reactants_evaluate},
  {NULL}
};

static void f2py_setup_reactants(char *nreactant1_atoms,char *reactant1_atoms,char *massfrac,char *nreactant2_atoms,char *max_atoms,char *rinf,char *reactant2_atoms,char *reactant1_center_of_mass,char *reactant2_center_of_mass,char *value,char *gradient,char *hessian,char *evaluate) {
  int i_f2py=0;
  f2py_reactants_def[i_f2py++].data = nreactant1_atoms;
  f2py_reactants_def[i_f2py++].data = reactant1_atoms;
  f2py_reactants_def[i_f2py++].data = massfrac;
  f2py_reactants_def[i_f2py++].data = nreactant2_atoms;
  f2py_reactants_def[i_f2py++].data = max_atoms;
  f2py_reactants_def[i_f2py++].data = rinf;
  f2py_reactants_def[i_f2py++].data = reactant2_atoms;
  f2py_reactants_def[i_f2py++].data = reactant1_center_of_mass;
  f2py_reactants_def[i_f2py++].data = reactant2_center_of_mass;
  f2py_reactants_def[i_f2py++].data = value;
  f2py_reactants_def[i_f2py++].data = gradient;
  f2py_reactants_def[i_f2py++].data = hessian;
  f2py_reactants_def[i_f2py++].data = evaluate;
}
extern void F_FUNC(f2pyinitreactants,F2PYINITREACTANTS)(void (*)(char*,char*,char*,char*,char*,char*,char*,char *,char *,char *,char *,char *,char *));
static void f2py_init_reactants(void) {
  F_FUNC(f2pyinitreactants,F2PYINITREACTANTS)(f2py_setup_reactants);
}

/*need_f90modhooks*/

/************** See f2py2e/rules.py: module_rules['modulebody'] **************/

/******************* See f2py2e/common_rules.py: buildhooks *******************/

/*need_commonhooks*/

/**************************** See f2py2e/rules.py ****************************/

static FortranDataDef f2py_routine_defs[] = {
  {"random_init",-1,{{-1}},0,(char *)F_FUNC_US(random_init,RANDOM_INIT),(f2py_init_func)f2py_rout__main_random_init,doc_f2py_rout__main_random_init},
  {"random_init_seed",-1,{{-1}},0,(char *)F_FUNC_US(random_init_seed,RANDOM_INIT_SEED),(f2py_init_func)f2py_rout__main_random_init_seed,doc_f2py_rout__main_random_init_seed},
  {"random",-1,{{-1}},0,(char *)F_FUNC(random,RANDOM),(f2py_init_func)f2py_rout__main_random,doc_f2py_rout__main_random},
  {"randomn",-1,{{-1}},0,(char *)F_FUNC(randomn,RANDOMN),(f2py_init_func)f2py_rout__main_randomn,doc_f2py_rout__main_randomn},
  {"rfft",-1,{{-1}},0,(char *)F_FUNC(rfft,RFFT),(f2py_init_func)f2py_rout__main_rfft,doc_f2py_rout__main_rfft},
  {"irfft",-1,{{-1}},0,(char *)F_FUNC(irfft,IRFFT),(f2py_init_func)f2py_rout__main_irfft,doc_f2py_rout__main_irfft},

/*eof routine_defs*/
  {NULL}
};

static PyMethodDef f2py_module_methods[] = {

  {NULL,NULL}
};

static struct PyModuleDef moduledef = {
  PyModuleDef_HEAD_INIT,
  "_main",
  NULL,
  -1,
  f2py_module_methods,
  NULL,
  NULL,
  NULL,
  NULL
};

PyMODINIT_FUNC PyInit__main(void) {
  int i;
  PyObject *m,*d, *s, *tmp;
  m = _main_module = PyModule_Create(&moduledef);
  Py_SET_TYPE(&PyFortran_Type, &PyType_Type);
  import_array();
  if (PyErr_Occurred())
    {PyErr_SetString(PyExc_ImportError, "can't initialize module _main (failed to import numpy)"); return m;}
  d = PyModule_GetDict(m);
  s = PyString_FromString("$Revision: $");
  PyDict_SetItemString(d, "__version__", s);
  Py_DECREF(s);
  s = PyUnicode_FromString(
    "This module '_main' is auto-generated with f2py (version:2).\nFunctions:\n"
"  random_init()\n"
"  random_init_seed(value)\n"
"  rn = random()\n"
"  rn = randomn()\n"
"  rfft(x,n=len(x))\n"
"  irfft(x,n=len(x))\n"
"Fortran 90/95 modules:\n""  system --- beta,mass,mode,max_atoms,dt,pi,thermostat,andersen_sampling_time,max_gle_ns,gle_ns,gle_a,gle_c,equilibrate(),recrossing_trajectory(),umbrella_trajectory(),verlet_step(),free_ring_polymer_step(),constrain_to_dividing_surface(),constrain_momentum_to_dividing_surface(),add_umbrella_potential(),add_bias_potential(),get_reaction_coordinate(),get_recrossing_flux(),get_recrossing_velocity(),sample_momentum(),get_ring_polymer_energy(),get_kinetic_energy(),get_center_of_mass(),get_centroid(),get_radius_of_gyration(),update_vmd_output()""  transition_state --- max_ts,max_atoms,number_of_bonds,forming_bond_lengths,breaking_bond_lengths,max_bonds,number_of_transition_states,breaking_bonds,forming_bonds,evaluate_all(),value(),gradient(),hessian(),evaluate()""  reactants --- nreactant1_atoms,reactant1_atoms,massfrac,nreactant2_atoms,max_atoms,rinf,reactant2_atoms,reactant1_center_of_mass(),reactant2_center_of_mass(),value(),gradient(),hessian(),evaluate()"".");
  PyDict_SetItemString(d, "__doc__", s);
  Py_DECREF(s);
  _main_error = PyErr_NewException ("_main.error", NULL, NULL);
  /*
   * Store the error object inside the dict, so that it could get deallocated.
   * (in practice, this is a module, so it likely will not and cannot.)
   */
  PyDict_SetItemString(d, "__main_error", _main_error);
  Py_DECREF(_main_error);
  for(i=0;f2py_routine_defs[i].name!=NULL;i++) {
    tmp = PyFortranObject_NewAsAttr(&f2py_routine_defs[i]);
    PyDict_SetItemString(d, f2py_routine_defs[i].name, tmp);
    Py_DECREF(tmp);
  }




































/*eof initf2pywraphooks*/
  PyDict_SetItemString(d, "reactants", PyFortranObject_New(f2py_reactants_def,f2py_init_reactants));
  PyDict_SetItemString(d, "transition_state", PyFortranObject_New(f2py_transition_state_def,f2py_init_transition_state));
  PyDict_SetItemString(d, "system", PyFortranObject_New(f2py_system_def,f2py_init_system));
/*eof initf90modhooks*/

/*eof initcommonhooks*/


#ifdef F2PY_REPORT_ATEXIT
  if (! PyErr_Occurred())
    on_exit(f2py_report_on_exit,(void*)"_main");
#endif
  return m;
}
#ifdef __cplusplus
}
#endif
